<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TINY PASSAGES</title>
      <link href="/2022/03/07/TinyPassages/"/>
      <url>/2022/03/07/TinyPassages/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Everyone-has-their-own-time-zone"><a href="#Everyone-has-their-own-time-zone" class="headerlink" title="Everyone has their own time zone"></a>Everyone has their own time zone</h1><style>span::first-letter {    font-size:20px;}</style><span style="font-family: Georgia, serif; font-size:15px;"><span  style="font-family: Georgia, serif; font-size:25px;">N</span>ew York is 3 hours ahead of California,<p>but it does not make California slow.</p><p>Someone graduated at the age of 22,</p><p>but waited 5 years before securing a good job!</p><p>Someone became a CEO at 25,</p><p>and died at 50</p><p>While another became a CEO at 50,</p><p>and lived to 90 years.</p><p>Someone is still single,</p><p>while someone else got married.</p><p>Obama retires at 55,</p><p>but Trump starts at 70.</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>People around you might seem to go ahead of you,</p><p>some might seem to be behind you.</p><p>But everyone is running their own RACE, in their own TIME.</p><p>Don’t envy them or mock them.</p><p>They are in their TIME ZONE, and you are in yours!</p><p>Life is about waiting for the right moment to act.</p><p>So, RELAX.</p><p>You’re not LATE.</p><p>You’re not EARLY.</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.<br></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Literal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM PROJECT</title>
      <link href="/2021/09/17/AssemblyLearning/"/>
      <url>/2021/09/17/AssemblyLearning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><em>Based on Assembly Edition 4</em></p><h3 id="Basic-Part"><a href="#Basic-Part" class="headerlink" title="Basic Part"></a>Basic Part</h3><h3 id="Memory-Segmentation-in-8086-Microprocessor"><a href="#Memory-Segmentation-in-8086-Microprocessor" class="headerlink" title="Memory Segmentation in 8086 Microprocessor"></a>Memory Segmentation in 8086 Microprocessor</h3><h4 id="存储器-、存储单元"><a href="#存储器-、存储单元" class="headerlink" title="存储器 、存储单元"></a>存储器 、存储单元</h4><p><code>存储器</code> 也就是我们平时所说的<code>内存</code> 。 负责为CPU提供指令和数据 , 在一台PC机中内存的作用仅次于CPU,存储器被划分为若干个<code>存储单元</code>, 每个存储单元从0开始顺序编号. 一般微型机的存储器的存储单元可以存储一个<code>Byte</code>,即一个字节(8个二进制位) - <code>微机存储器容量的最小单位</code>。</p><p>一般应具有 存储数据 和 读写数据 的功能， 每个单元有一个地址，是一个整数 编码 ，可以表示为 二进制 整数。</p><p>磁盘不同于内存,磁盘上的数据或程序不读取到内存中就无法被CPU使用</p><h4 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h4><p>存储单元在存储器中顺序编号，这些编号可以看作存储单元在存储器中的地址。</p><p>计算机中 连接 CPU 与其他芯片的导线被称作是 <code>&quot;总线&quot;</code> ,<br>根据传输信息的不同， 其从逻辑上可分为三类 : </p><ul><li><p>地址总线 (CPU通过地址总线来指定存储器单元)</p><p>地址总线的宽度<code>(位数)决定了CPU寻址的最大空间大小,假设一个CPU有10根地址总线,其寻址最大数为2^10 = 1024个</code>  最小数为0,最大数为1023</p><p>地址总线可寻到的内存单元构成了这个CPU的<code>内存地址空间</code>。</p></li><li><p>控制总线</p><p>控制总线的宽度决定了CPU对外部器件的控制能力。</p><p>CPU通过地址总线来指定存储单元 ，控制总线上能传送信息的多少（控制总线的宽度），决定了CPU可以对多少个存储单元进行寻址。</p></li><li><p>数据总线</p><p>数据总线的宽度决定了<code>CPU与外界的数据传输速度</code> , 8根数据总线可以一次传送8位二进制数据 (即1Byte),</p><p>计算机的字长即取决于数据总线的宽度.</p></li></ul><h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>CPU操作存储器(RAM ROM 带有BIOS的ROM)时将他们看作内存来对待,将他们总的看作一个<code>由若干个存储单元组成的逻辑存储器</code>. 这个逻辑存储器就是所说的内存空间地址.</p><p>每一个物理存储器在这个逻辑存储器中占有一个地址段,即一段<code>地址空间</code>,对于CPU来说,在这段地址空间中进行数据读写 , 实际也就是对对应的物理存储器进行读写.</p><p>因为内存空间地址与存储单元相关,其大小受到CPU地址总线宽度的限制,例如8086CPU的地址总线为<code>20</code>,则其可以传送<code>2^20</code>个不同的地址信息<code>(0 ~ 2^20-1)</code>,也就是可以定位<code>2^20</code>个内存单元,则其内存地址空间大小为 <code>2^20 / 1024^2</code></p><p>在基于一个计算机硬件进行系统编程时,必须知道这个系统中内存地址的分配情况, 在对某类存储器进行数据读写时,必须知道它的第一个单元的地址和最后一个单元的地址,才能保证读写操作是在预期的存储器中进行的.</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU由运算器 \ 寄存器 \ 控制器 等器件组成,这些器件靠内部的总线相连..</p><p>内部总线实现CPU内部各个器件之间的联系外部总线实现CPU和主板上其他器件的联系</p><h4 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h4><p>字(记为<code>word</code>) , 一个字由2个字节组成 这两个字节分别称为这个字的<code>高位字节</code>和<code>低位字节</code>.</p><p>一个十六进制数 = 4个二进制的四位</p><h4 id="几条汇编指令与8086CPU给出物理地址的方式"><a href="#几条汇编指令与8086CPU给出物理地址的方式" class="headerlink" title="几条汇编指令与8086CPU给出物理地址的方式"></a>几条汇编指令与8086CPU给出物理地址的方式</h4><p>在进行数据传送或运算时,要注意两个操作对象的位数应当是一致的. 高低位对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">add al.bl</span><br><span class="line">add ah,bh</span><br></pre></td></tr></table></figure><p><code>8086CPU</code>有20位地址总线,可以传送20位地址,寻址能力 2^20(bytes) / 1024(bytes)^2 = <code>1MB</code></p><p>内部采用2个16位地址合成的方法来形成一个20位的物理地址(一个称为<code>段地址 </code>, 一个称为<code>偏移地址</code>)</p><p>段地址和偏移地址通过内部总线被送入一个称作<code>地址加法器</code>的部件中,由它将两个16位的地址组合为20位的物理地址</p><p>地址加法器通过<code>物理地址 = 段地址 × 16(d) + 偏移地址</code>的方式合成物理地址</p><hr><p><code>段地址 × 16</code> 常用说法 <code>左移4位</code>(指二进制位) , 相当于 乘 2^4</p><p>关于8086CPU的物理地址的五位十六进制数表示方式:</p><p>因为其寻址能力为1MB , 一位十六进制数相当于4位二进制数 , 所以五位十六进制数 = 4*5 = 20位 = 2^20 = 1MB 正好符合了8086CPU的寻址能力范围.</p><h4 id="测验题解-2-2"><a href="#测验题解-2-2" class="headerlink" title="测验题解 - 2.2"></a>测验题解 - 2.2</h4><p>有意思的题目…</p><blockquote><p>有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为 ? 最大为 ?</p></blockquote><p>最大值: 比较好求, 设SA为x, 则 EA为 <code>0000H</code>, x = 20000H / 16 = 2000H</p><p>最小值: EA 最大 为<code>FFFF</code>, 则段地址为 2 0000H - FFFF 后右移4位(逆向) 结果 1000H,但是经过验算结果非20000H 而是 <code>1FFFF</code>,初见这我也觉得很奇怪… (我的计算器绝对没有问题.jpg) 但其实<code>1FFFF即段地址1000H的最大寻址范围</code> , 与所需求内存单元就差 1 , 所以1000H + 1 = <code>1001H</code> 这才是正确的值.<code>也即是最小满足SA条件的值</code></p><hr><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;"><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span><a href="https://docs.microsoft.com/zh-cn/windows/terminal/" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">CSDN</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Assembly Quiz 2.2"</span></div><p>好怪但雀氏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(20000H-ffffH)&#x2F;16</span><br><span class="line">&#x3D;(10001)&#x2F;16</span><br><span class="line">这里如果不按传统算数先算括号里，而是把括号打开再算。结果就对了</span><br><span class="line">20000H &#x2F; 16 - FFFFH &#x2F; 16</span><br><span class="line">2000H - 0FFFH &#x3D; 1001H</span><br></pre></td></tr></table></figure><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>8086CPU有四个段寄存器 : CS \ DS \ SS \ ES</p><p>CS:IP 是8086CPU中最关键的俩个寄存器 , 它们指示了 CPU 当前要读取指令的地址</p><p>CS为<code>代码段寄存器 (Code Section)</code>  IP为指令<code>指针寄存器 (Instruction Pointer)</code></p><p><code>CS * 16 + IP = 物理地址</code></p><h4 id="关于-IP-CS-的修改"><a href="#关于-IP-CS-的修改" class="headerlink" title="关于 IP / CS 的修改"></a>关于 IP / CS 的修改</h4><p>能改变IP / CS 内容的指令被统称为<code>转移指令</code>, 目前可以用一个简单的指令来修改它们 :<code>jmp 指令</code></p><p>指令形如 <code>jmp 段地址:偏移地址</code>, 将CS修改为段地址, IP修改为偏移地址</p><p>或者使用 <code>jmp 合法寄存器</code>来修改<code>IP</code>的内容</p><p>e.g.  <code>jmp ax =&gt; mov IP,ax</code>  jmp指令的功能类似于这样子</p><h3 id="寄存器与内存访问"><a href="#寄存器与内存访问" class="headerlink" title="寄存器与内存访问"></a>寄存器与内存访问</h3><p>DS寄存器(数据段寄存器 ,  data segment register)通常用来存储要访问数据的<code>段地址</code></p><h4 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h4><p>栈 – 拥有特殊访问方式的存储空间 –  <code>LIFO 后进先出</code>, CPU提供的最基本两个指令是 <code>PUSH(入栈) 和 POP(出栈)</code>,它们的操作都是以<code>字</code>为单位进行的</p><p>SS \ SP 寄存器 – <code>( Stack Segement ) / ( Stack Pointer )</code>,任意时刻 <code>SS:SP</code> 都指向栈顶元素,CPU将从此处取得<code>栈顶</code>的地址  , 注意 CPU 只记录栈顶,栈空间的大小需要自己管理</p><h4 id="pop-push-的执行过程"><a href="#pop-push-的执行过程" class="headerlink" title="pop / push 的执行过程"></a>pop / push 的执行过程</h4><blockquote><p>执行push时.CPU的两步操作是: 先改变SP, 后向SS:SP处传送, 执行 pop时, CPU的两步操作是:先读取SS:SP处的数据,后改变SP</p></blockquote><h4 id="栈综述"><a href="#栈综述" class="headerlink" title="栈综述"></a>栈综述</h4><p>将一段内存当作栈段, 这是我们自己在编程中的安排, 想要pop / push 等栈操作指令访问我们定义的栈段,就得将<code>SS:SP</code>指向我们定义的栈段</p><p>一个栈段的最大容量为<code>64KB</code></p><p>栈满时继续压栈将导致栈顶环绕</p><h3 id="程序执行过程与跟踪"><a href="#程序执行过程与跟踪" class="headerlink" title="程序执行过程与跟踪"></a>程序执行过程与跟踪</h3><p>程序由<code>Shell</code>(操作系统的外壳程序,用户使用Shell来操作计算机系统进行工作  如DOS中的<code>command.com</code>就是一个Shell) 加载入内存, 之后Shell将设置<code>CS:IP</code>来指向程序的<code>入口点</code>, 然后暂停运行, 将程序交给CPU执行.</p><p>待任务执行完毕后, 控制返回到Shell , 屏幕显示由当前盘符和当前路径组成的提示符,等待用户输入.</p><h3 id="📌-实验三-编程-编译-连接-跟踪-分析"><a href="#📌-实验三-编程-编译-连接-跟踪-分析" class="headerlink" title="📌 实验三 - 编程|编译|连接|跟踪     - - 分析"></a>📌 实验三 - 编程|编译|连接|跟踪     - - 分析</h3><blockquote><p> debug 跟踪以下程序执行过程 , 记录每步执行后相关寄存器中内存和栈顶内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,2000H</span><br><span class="line">    mov ss,ax ; ss &#x3D; ax &#x3D; 2000H</span><br><span class="line">    mov sp,0</span><br><span class="line">    add sp,10 ; sp &#x3D; AH</span><br><span class="line">    ;; 注意pop执行顺序 , 首先将栈顶内容送入对应寄存器 , 再更新SP(栈偏移地址)</span><br><span class="line">    pop ax  ; 内存追踪 ax &#x3D; 076cH , SP 新指向下个字开始处 &#x3D; SP + 2 &#x3D; C  ,   新栈顶 2000:C</span><br><span class="line">    pop bx ;  bx &#x3D; 01a4H , SP &#x3D; SP + 2 &#x3D; E 新栈顶 2000:E</span><br><span class="line">    </span><br><span class="line">    ;; 执行顺序与pop相反 , 优先处理SP , 再处理压栈操作</span><br><span class="line">    push ax ; sp &#x3D; sp - 2 &#x3D; C , 将 ax 入栈 到 2000:C(D) &#x3D;&gt; 01A4H &#x3D;&gt; 076CH(结果)</span><br><span class="line">    push bx ; sp &#x3D; sp -2 &#x3D; A , bx 入栈 至 2000:A(B) &#x3D;&gt; 01A4H &#x3D;&gt; 01A4H</span><br><span class="line">    </span><br><span class="line">    pop ax ; 出栈 , ax &#x3D; 01A4H , sp &#x3D; sp + 2 &#x3D; C </span><br><span class="line">    pop bx ; 出栈 , bx &#x3D; 076CH , sp &#x3D; E</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h ; ax &#x3D; 4c00H</span><br><span class="line">    int 21h ; p</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>✨</p><h3 id="Base-Register-And-Loop-instruction"><a href="#Base-Register-And-Loop-instruction" class="headerlink" title="Base Register And Loop instruction"></a>Base Register And Loop instruction</h3><p><code>[bx]</code>(base, 基址寄存器 , 常用于地址索引 )实际为一个偏移地址EA , 段地址SA默认存放在<code>DS</code>中</p><p>Loop 指令格式 :<code> loop 标号</code> ,  通过loop指令实现循环功能 , 通过 <code>CX ( count )寄存器</code>控制循环次数 </p><p>执行顺序 : </p><ul><li>(cx) = (cx) -1</li><li>判断 若 cx &gt; 0 , 则向前转至 <code>标号</code> 处执行 , 若 cx = 0 , 则继续向下执行</li></ul><p>值得注意的是, 这里跳转到 标号 处,相当于高级语言中常见的 for \ while 等 循环中常见的 条件循环 , 汇编实现为 jle,jmp,jne等. 或许之后会详细提到</p><p>总体程序框架:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s: ; 标号:需要循环的程序段</span><br><span class="line">loop s ; loop label</span><br></pre></td></tr></table></figure><p><strong>Pseudo code</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CX &#x3D; CX - 1</span><br><span class="line">if CX &lt;&gt; 0 then</span><br><span class="line">jump to label</span><br><span class="line">else</span><br><span class="line">no jump, continue</span><br></pre></td></tr></table></figure><h4 id="Debug和汇编编译器MASM对指令的不同处理"><a href="#Debug和汇编编译器MASM对指令的不同处理" class="headerlink" title="Debug和汇编编译器MASM对指令的不同处理"></a>Debug和汇编编译器MASM对指令的不同处理</h4><p>若处理以<code>[]</code>包含的指令时, 型如<code>[idata]</code>,它们的处理结果如下</p><p>Debug 将”<code>[idata]</code>“视作一个内存单元, 将内部<code>idata</code>作为内存单元的偏移地址</p><p>编译器将<code>[idata]</code>解释作<code>idata</code></p><p><code>如果要让编译器将其解释为一个 内存单元, 则必须在[]前显式的给出段地址DS</code></p><h4 id="Concept-段前缀"><a href="#Concept-段前缀" class="headerlink" title="(Concept)段前缀"></a>(Concept)段前缀</h4><p>用于<strong>显式指明</strong>内存单元的段地址的<code>&quot;DS:&quot;,&quot;CS:&quot;,&quot;SS:&quot;,&quot;ES:&quot;</code>, 在汇编语言中被称为 <code>段前缀</code></p><h3 id="📌-实验四-bx-与Loop的使用-3-分析"><a href="#📌-实验四-bx-与Loop的使用-3-分析" class="headerlink" title="📌 实验四 - [bx]与Loop的使用 (3)     - - 分析"></a>📌 实验四 - [bx]与Loop的使用 (3)     - - 分析</h3><blockquote><p>补全程序 , 将 mov ax,4c00H 之前的指令复制到内存 0:200中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">; quiz3</span><br><span class="line">; cx &#x3D; 001BH &#x3D; 27D NOTE</span><br><span class="line">; 23 bytes before mov ah,4cH , i.e. 17H</span><br><span class="line"></span><br><span class="line">    ; when a programm was loaded to the memory , cs:ip will initialized as the first address of the programm</span><br><span class="line">    mov ax,cs    ; # 补全1</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0020H    ;  &#x3D; 0020:0 &#x3D; 00200 &#x3D; es</span><br><span class="line">    ; init target</span><br><span class="line">    mov es,ax   ; es extra segment register ( also refers to a segment in the memory which is another data segment in the memory.)</span><br><span class="line">    ; es stores the segment address of purpose</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,17H   ; 从 0 ~ cs:16H # 补全2</span><br><span class="line"></span><br><span class="line">    s:mov al,[bx]   ; ds:[bx]</span><br><span class="line">    mov es:[bx],al  ; es:[bx] &#x3D; 20:bx &#x3D; (20H*16+bx)</span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ah,4cH</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">; copy the instructions before mov ax,4c00h to 0:200</span><br><span class="line">; 23 bytes , 从debug中得之第一条指令到 mov ah,4ch 之前的指令占据23bytes的空间</span><br></pre></td></tr></table></figure><p>通过debug获取 程序的总字节量, 计算于 mov ax,4c00H之前的字节量.( 且注意debug中以十六进制表示的数据)</p><p>可以发现需要获取的数据在<code>076C:0017之前</code>,也就是从偏移地址<code>0~16</code>总共<code>23(17H)</code>个字节</p><p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/03/17/R9hmx5IPWtUeobj.png" alt="image-20220317111236284"></p><!--<span style="display: block; color: darkgray; font-size: 5px; font-style: italic; margin-top: -20px; margin-left:30%;">结果</span>--->]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> 系统 </tag>
            
            <tag> theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多引导系统启动盘制作</title>
      <link href="/2021/05/19/MultiUBoot/"/>
      <url>/2021/05/19/MultiUBoot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>‘这是一个简单的过程，当然也有其他的实现方式。’<br>嗯，其实早在这之前就有整多引导盘的想法了，不过当时没有合适的U盘来做 <span style="font-family:sans-serif">:3 </span><br>这几天还正好想把家里笔记本的系统恢复为在训练处的系统（毕竟自己将常用的一些东西也都装到上面了嘛…. ) 而且….. 光盘引导不知发什么神经了= =||…. 引导过程中总会出现一些问题。光盘还是得好好保管啊….</p><p>为了存储备份的系统，我还特意准备了一个拥有更大储存空间的U盘！</p><div style="text-align: center;"><img  src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/05/26/hADguStZrCMQeXs.jpg" alt="有点小贵，但很快乐 😳"  width="30" style="display: inline;"> <span style="display: block; color: darkgray; font-size: 5px; font-style: italic; margin-top: -20px;">有点小贵，但很快乐</span></div><p>于是我就用这个U盘来恢复系统啦、 还阔以根据自己的喜好或需要选择不同的PE、、</p><h3 id="准备时"><a href="#准备时" class="headerlink" title="准备时"></a>准备时</h3><ul><li>🌼 自行选择合适的PE系统</li><li>🌻 本期主角 <a target="_blank" rel="noopener" href="https://github.com/ventoy/Ventoy/releases/download/v1.0.44/ventoy-1.0.44-windows.zip">Ventoy</a> ( 1.0.44 Release )</li><li>🌴 一个U盘 （并不需要很大 哪怕是1G也没关系，根据需要就行  <span style="font-family:sans-serif">:3 </span>）</li></ul><h3 id="进行时"><a href="#进行时" class="headerlink" title="进行时"></a>进行时</h3><p>执行<code>ventoy</code> ，在 设备 下拉选项框中选择需要安装的U盘 ， 注意后续需要格式化，所以要做好U盘文件的备份工作喔、随后就执行安装吧。</p><p>安装完毕后，U盘将被重命名为<code>Ventoy</code>，此时就可以将备用的PE系统或系统镜像扔到U盘里边啦、<code>『 注意不要扔到ventoy的引导盘中 』</code><br>也可以放入一个新建文件夹中，便于管理。</p><p>重启系统 <code>进入BIOS并更改『 BIOS 启动序列 』</code> ， 将刚刚安装ventoy的U盘移至首位, 保存设置并重启。<br>然后，然后就可以看到ventoy的启动面啦、🥳</p><div style="text-align: center;"><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/05/27/SaPlEoRqZH9zNIk.jpg" alt="启动界面 "  width="50%" style="display: inline;"> <span style="display: block; color: darkgray; font-size: 5px; font-style: italic; margin-top: -20px;">Ventoy 启动界面，依旧是根据自己的需要选择 👋 ( 学校滴电脑，又把它重装了:x 嘘~</span></div>]]></content>
      
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSumTable</title>
      <link href="/2021/04/02/HashSumTable/"/>
      <url>/2021/04/02/HashSumTable/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感谢热心的<span>&nbsp;</span> <i style="color:#33ABDE; font-family: Georgia, serif;">Johann.C</i> <span>&nbsp;</span>进行算法测试、<br>这是今天在帮助实现赛项题目解时所发现的一个算法。我将其命名为<code>Hash Sum Table</code> ，为实现<code>以一和求其多和数</code> 最优解。这也是根据某算法进行的理论改动。<br>本人目前算法领域不精，慎阅，也欢迎讨论。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定整数数组<code>nums</code> 和一个整数值 <code>target</code>,在数组中找出可组为和<code>target</code>的数值。</p><h3 id="图文解"><a href="#图文解" class="headerlink" title="图文解"></a>图文解</h3><p>嗯…根据我当时画出的分析图来吧( 红色部分 )</p><div style="text-align: center; "><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/04/02/VQ1HGZv2u3TCq9x.jpg" alt="" style="width: 40%; display:inline-block;"></div>上部的`nums`为哈希表中的`V`下面索引即为`K`此处测试初始化 `target = 13`// 此处针对的是从小到大排列的数据集合， 关于去重会在后面解释将target值减去数组nums中值，得到新值（`如12 ， 13-1=12`）并将数组中被减去的值添加到`HashMap`中与下标对应, 此处即为上部的 `nums` ( 嘛...我确实应该直接把它命名为HashMap...就不需要我来解释了(😓) )再将新值按照之前步骤重复 ， 如果减到最后得到负值，那就从数组第一个数重新遍历计算，（但是相减得到负值的减数不要加入到HashMap中）如下图,<div style="text-align: center; "><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/04/02/pTHczlSWoQLKI2F.jpg" alt="" style="width: 40%; display:inline-block;"></div><p>最后计算哈希表中<code>出现的下标次数 乘 对应的值 其和即为target</code></p><p>也许你也发现了，这样的算法会出现重复的值，关于去重，即将数组以从大到小的顺序排列，中间遇到负值的情况直接跳过计算下一个数即可 . 可防止重复值的出现。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>附上在下的腊鸡代码      <span style=" font-family: Georgia, serif;">•́ω•̀)</span></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ICollection <span class="title">HashSumTable</span>(<span class="params"><span class="keyword">int</span>[] ar, <span class="keyword">int</span> target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, temp = target;</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">int</span> length = ar.GetLength(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// init HashTable  ;; To exclude duplicating numbers,  sort the table reversed</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123; hashtable.Add(ar[i].ToString(), <span class="number">0</span>); total += ar[i]; &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; total) &#123; Console.WriteLine(<span class="string">&quot;No current result....&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>,i=length<span class="number">-1</span>; j &lt;length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp -= ar[j];</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123; temp = target; i--;  <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            target = temp;</span><br><span class="line">            <span class="comment">// Write into HashTable</span></span><br><span class="line">            hashtable[i.ToString()] = ar[j];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashtable.Values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NETWORK PROTOCOL</title>
      <link href="/2021/02/17/Network-Protocol/"/>
      <url>/2021/02/17/Network-Protocol/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>此处后台开发使用的是Java 需要安装<code>Java SE Development Kit</code>  JDK 内已含JVM (java虚拟机)<br>篇幅将涉及到Java基础</p><h2 id="服务器与客户端"><a href="#服务器与客户端" class="headerlink" title="服务器与客户端"></a>服务器与客户端</h2><p>两者其实皆计算机，不过两者的需求不一样<br>客户端通过<code>端口</code>发送请求给服务器，端口用于<code>监听</code>，以运行一个软件（为服务器软件） 来处理客户端发送的请求/数据    即服务器软件占用一个端口用以监听数据的传输<br>返回数据： 同样的，返回数据即是服务器通过之前的端口将数据发送到客户端（中间过程会比较复杂，可能会牵扯到网卡接口等····）</p><p>要接收到数据，必须由一个<code>服务器软件</code>占有一个端口并监听数据<br>既然此处使用java作为后台开发，使用<code>Tomcat</code>作为服务器软件，正好其就是使用java开发的服务器软件，需要在使用<code>jvm</code>启动后才能使用<br>所以整个过程大概就是 客户端发送请求到监听某端口的服务器软件（由JVM启动），再运行服务器中对应的Java代码</p><p>互联网环境下，每台计算机都有自己唯一的IP地址，此处则使用Ip地址来访问指定服务器<br>若是使用http协议访问服务器，那提供的目标地址格式差不多如下<br><code>http://IP地址:端口号/项目</code></p><h2 id="网络互联模型"><a href="#网络互联模型" class="headerlink" title="网络互联模型"></a>网络互联模型</h2><p>国际标准化组织ISO 于 1985年制定了 <code>网络互联模型 OSI</code></p><p>OSI参考模型具有 7层结构。 为ISO制定<br>而TCP/IP协议具有 四层结构  广为人知<br>在学术研究中 一般将<code>物理层</code>和<code>数据链路层</code>分开讲解，具有 <code>五层结构</code></p><p>数据由客户端发送到服务器，途中会经过包装和解包、</p><p>LocalHsot\127.0.0.1 属于<code>环回地址 Lookback Address</code>（即访问当前主机）</p><h2 id="搭建Java服务器开发环境"><a href="#搭建Java服务器开发环境" class="headerlink" title="搭建Java服务器开发环境"></a>搭建Java服务器开发环境</h2><p>使用<code>IDEA + Tomcat</code>搭建完毕本地服务器后，<br>通过 <code>本机ip/localhost/127.0.0.1 + 端口号 + 项目名</code>即可访问本地服务器项目，<br>建立服务器后，<code>服务器将查找 index.htm / index.html / index.jsp</code> 作为主页打开</p><p>Java的工程结构由 <code>包(文件夹层级？。。) + 类名</code>构成  —- 相当于<code>C#中的命名空间</code><br>其包有个约定俗成的命名方式：即<code>将域名倒过来</code> 如在下的博客域名 <code>fxlabtinystar.cn</code><br>那包名可以是 <code>cn.fxlabtinystar.xxxx(模块、功能啥的)</code><br>在实际目录中则变成了以 点号 分层目录</p><h2 id="网络环境模拟"><a href="#网络环境模拟" class="headerlink" title="网络环境模拟"></a>网络环境模拟</h2><p>这一部分使用了<code>Cisco Packet Tracer</code>(一款网络仿真程序)<br>使用<code>ping</code>测试网络状态，两台计算机的首次连接，ping的发起机通过<a href="https://baike.baidu.com/item/ARP/609343?fr=aladdin">ARP协议</a>获取了接收机的<code>MAC地址</code>（只知道IP地址可不行，数据输送必须知道MAC网卡地址）走完ARP协议后，即已经获取了目标机器的MAC地址，此时可以使用ICMP协议进行ping的实现了</p><p>关于Packet Tracer事件列表中显示连续三个一样类型的协议：这并不是三次使用该类型协议，而是完整的一次，从开始 - 发出数据 - 接收数据</p><p>两台电脑（相同设备）之间直接互联需要用到的网线是<code>交叉线</code>而非直通线</p><h3 id="计算机之间的连接方式"><a href="#计算机之间的连接方式" class="headerlink" title="计算机之间的连接方式"></a>计算机之间的连接方式</h3><h4 id="同轴电缆-Coaxial"><a href="#同轴电缆-Coaxial" class="headerlink" title="同轴电缆 Coaxial"></a>同轴电缆 Coaxial</h4><ul><li>属于半双工通信（同一时间只允许一台设备发送数据）</li><li>容易冲突 （由 冲突域）</li><li>不安全</li><li>中间断了，整个网络环境会瘫痪</li><li>无智商！</li></ul><h4 id="集线器-Hub"><a href="#集线器-Hub" class="headerlink" title="集线器 Hub"></a>集线器 Hub</h4><p>“集线器的英文称为“Hub”。“Hub”是“中心”的意思”</p><ul><li>也属于半双工模式</li><li>容易冲突</li><li>不安全</li><li>也无智商！<br>HUB无存储功能，无法缓存MAC地址,<br>可以使用<code>arp -a</code> 查看当前计算机的缓存MAC地址</li></ul><h4 id="网桥-Network-Bridge"><a href="#网桥-Network-Bridge" class="headerlink" title="网桥 Network Bridge"></a>网桥 Network Bridge</h4><p>也是用于连接同一个网段</p><ul><li>能够通过自学习得知每个接口那侧的MAC地址</li><li>起到隔绝冲突域的作用（这样同一冲突域内的计算机传数据就不会占用另一冲突域的数据链路）<br>网桥会记录MAC地址</li></ul><h4 id="交换机-Switch"><a href="#交换机-Switch" class="headerlink" title="交换机 Switch"></a>交换机 Switch</h4><ul><li>相当于接口更多的网桥（每个接口能记录对应的MAC地址）</li><li>全双工通信 ★</li><li>比集线器安全<br><code>和上面所提设备一样连接的设备必须处于同一个网段</code><br>关于全世界都是用交换机连接网络的后果：在首次与另一台计算机通信的时候，为了获取MAC地址而使用ARP协议进行广播，即为全世界的计算机发送了广播…..会导致造成广播风暴</li></ul><h4 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器 Router"></a>路由器 Router</h4><ul><li>可以在不同网段之间转发数据</li><li>隔绝广播域 （处于不同广播域的计算机无法转换数据</li></ul><hr><p>主机发送数据之前，<code>首先判断目标主机的IP地址是否和当前主机处于同一个网段</code><br>若是处于同一个网段：发ARP、再通过交换机或集线器传送数据<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/04/SJ6wXgOmVBW9KfY.png" style="margin:0 auto; width:50%;"><br>不在同一个网段：则通过路由器转发数据  </p><p>那么此时就有了一个新的概念：<code>网关 - Gateway</code> （<code>由路由器提供</code>）<br> 网关拥有MAC地址<br>跨网段传输数据的时候需要通过网关，由主机广播ARP以获取路由器<code>当前局域网网关的MAC地址</code>并发送数据,再由另一网段网关ARP获取<code>目标主机的MAC地址</code>并发送数据<br>所以路由器一大作用显著： <code>跨网段传输数据</code> </p><blockquote><p> 📌 注意：数据跨网段传输，主机需要设置默认网关，和所在局域网网关处于同一网段内。</p></blockquote><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><blockquote><p>MAC地址 (Media Access Control Address) 直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address） </p></blockquote><p>每个网卡都有一个6字节<code>（48bit）</code>的MAC地址<br>MAC地址是全球唯一的，固化在网卡的<code>ROM</code>中，由<code>IEEE802</code>标准规定</p><p>前三个字节为<code>Organizationally unique identifier (OUI) “组织唯一标识符”</code>由IEEE的注册管理机构分配给厂商<br>后面的三个字节为 <code>网络接口标识符</code>，由厂商自行分配</p><p>MAC地址是可修改的，可分为静态MAC地址（Static）和动态MAC地址( Dynamic )，一般<br>动态MAC地址有<code>时效性</code>，根据操作系统的不同这个时间也会有所不同,过期后会自动删除，而静态MAC地址可以长时间保留，其可以通过手动添加，指令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arp -s [主机地址] [MAC地址]</span><br><span class="line"></span><br><span class="line">#查询ARP缓存</span><br><span class="line">arp -a [主机地址]</span><br><span class="line"></span><br><span class="line">#删除ARP缓存</span><br><span class="line">arp -d [主机地址]</span><br><span class="line"></span><br><span class="line">如果上述两条指令未添加主机地址，则是对所有ARP缓存做出指令执行。</span><br></pre></td></tr></table></figure><h2 id="IP地址-Internet-Protocol-Address"><a href="#IP地址-Internet-Protocol-Address" class="headerlink" title="IP地址 Internet Protocol Address"></a>IP地址 Internet Protocol Address</h2><p>所有主机都具有一个IP地址，最初是<code>IPV4</code>版本，32bit(4字节) 2019年11月25日，全球的IP地址已经用完<br>后来有了IPV6版本，128bit (16字节)</p><p>IP地址由<code>网络标识（网络ID）</code>和<code>主机标识（主机ID）</code>两部分组成<br>同一网段的计算机，网络ID相同。</p><p>可以通过<code>子网掩码（Subnet mask）</code>计算出网络ID 计算式：<br><code>子网掩码 &amp; IP地址</code></p><p>IP地址分为了 A-E类地址。</p><p>如果ping主机的ip地址 的主机ID部分 为 全1 （即255） ，那么此IP为广播IP地址，<br>即将数据包发送到此网段内的所有计算机<br>而网络ID部分为全0的话，即表示此IP代表一个网段</p><h3 id="子网掩码的CIDR表示法"><a href="#子网掩码的CIDR表示法" class="headerlink" title="子网掩码的CIDR表示法"></a>子网掩码的CIDR表示法</h3><p><code>CIDR （Classless inter-Domain Routing）</code> : 无类别域间路由<br>子网掩码的CIDR表示方法<br>192.168.1.100/24 表示子网掩码由24个1，也就是255.255.255.0</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计</title>
      <link href="/2021/02/17/C-Programming-Language-Learning/"/>
      <url>/2021/02/17/C-Programming-Language-Learning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>加深代码理解系列…..<i class="iconfont" style="font-size: larger;">&#xe679;</i></p><div class="note info"><p>Welcome to the wild no heroes and villains.</p></div><h3 id="高级计算机语言和编译器"><a href="#高级计算机语言和编译器" class="headerlink" title="高级计算机语言和编译器"></a>高级计算机语言和编译器</h3><p>C语言本身是高级语言，所谓高级编程语言，就是一种独立于机器，面向过程(POP)或是面向对象(OOP)的编程语言、<br>C语言就是一门<code>面向过程</code>的编程语言。<br>使用高级语言可以在更抽象的层面表达程序员的想法而不必要考虑CPU在完成任务时具体需要哪些步骤。（叒又是抽象，所以具象是否是表示接近一项事物的本质呢？）<br>计算机自己并不理解高级语言其高级指令，在这里编译器派上了用场，<code>它将高级语言程序翻译成计算机可以理解的机器语言指令集程序。</code><br>在学习C语言之前，有必要了解一下其编程机制。</p><h3 id="C的编程机制"><a href="#C的编程机制" class="headerlink" title="C的编程机制"></a>C的编程机制</h3><p>C是可移植性语言，所以可以在多种环境中运行使用，包括UNIX,Linux,MS-DOS,Windows,Mac OS<br>常说C\C++是跨平台语言，其原理是<code>使用平台相关的编译器生成对应平台的可执行文件</code>，如在Windows中.c.cpp文件将被编译成<code>PE格式</code>，而在Linux系统中将会被编译成<code>ELF格式</code><br>以上提到的也许只是部分环境，但终究他们有一些共有的方面。</p><p>C的代码被储存在文本文件中，该文件被称为“源代码文件 - <em>Source code file</em>”<br>通常由 <code>basename</code>基本名 + <code>.c (extension)</code>扩展名构成</p><p>C通过编译和链接将源代码文件转换为可执行文件。编译器将源代码转换成中间代码（通常为机器语言代码），链接器把中间代码与其他代码进行合并<code>（合并代码）</code>，最后再与<code>库文件</code>和<code>系统的标准启动代码</code>合并生成可执行文件。</p><h3 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h3><p><code>上溢（overflow）</code> 计算导致的数字过大，超过当前类型所能表达的范围时，就发生了上溢，现代C语言发生这种情况会给上溢的数据赋值一个表示<code>无穷大</code>的特定值。</p><p>使用数据类型时，若是将一个值初始化给不同类型的变量时，编译器会<code>自动转换成变量匹配的类型</code>，这可能会导致部分数据丢失。  比如将一个double 值赋给   float 变量，由于C语言只会保留float的前六位精度，其他位的数据将被丢弃。</p><h3 id="Refresh-Output"><a href="#Refresh-Output" class="headerlink" title="Refresh Output"></a>Refresh Output</h3><p>关于<code>printf</code> 何时将语句输出到终端，起初printf 会将语句发送到<code>缓冲区</code> (buffer )【作为中间储存区域】 中，由于C标准的明确规定， printf 在遇到  换行符、 缓存区满时会将内容输出到屏幕，这一过程为刷新缓存区。 如果没有换行符且缓存区也没有满，但是下一条语句为 <code>scanf()</code>语句时，scanf要求用户输入，此时 printf 将被迫将缓存区内容输出</p><h3 id="Pointer-amp-Multiple-Array-指针与多维数组"><a href="#Pointer-amp-Multiple-Array-指针与多维数组" class="headerlink" title="Pointer &amp; Multiple Array - 指针与多维数组"></a>Pointer &amp; Multiple Array - 指针与多维数组</h3><p>指针是一个值为内存地址的变量(或数据对象)</p><p>*(星号) , 即<code>间接运算符(indirection operator)</code>,  即间接获取指针指向地址处的数据</p><p>其也称为 解引用运算符(<code>dereferencing operator</code>)</p><p>e.g. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pt;</span><br><span class="line"><span class="comment">// 对pt的描述 , pt的类型:  指向char类型的指针</span></span><br></pre></td></tr></table></figure><h4 id="Declaration-of-Pointer-指针声明"><a href="#Declaration-of-Pointer-指针声明" class="headerlink" title="Declaration of Pointer 指针声明"></a>Declaration of Pointer 指针声明</h4><p>指针的声明需要指定<code>指针所指向的变量的类型</code>,不同的数据类型占据不同的内存空间</p><p>通常在声明的时候有空格, 间接运算符和指针名之间的空格可有可无(一般省略)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// arr是一个指向int类型数组的指针, 且每个数组中含有4个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>REFER TO PAGE 304</p></blockquote><p>为什么要使用圆括号? 因为<code>[]</code>的优先级高于<code>* </code>如果此处不使用圆括号, 则 <code>int *arr[4] </code>表示 <code>arr is a array point to pointer</code></p><p>即 <code>arr[4] 为一个数组, *表示arr数组中含有4个指针,int 表示每个指针指向的类型为int</code></p><p>注意使用数组法声明多维数组时,第二个方括号中的数据不能为空. 否则编译器无法知道.</p><p>数组名(第一个元素的地址) + 1 需要加上多少字节才能到第二个元素的地址</p><p>如 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[][<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>; </span><br><span class="line"><span class="comment">// ar+1 编译器将会将当前地址向后移动 16个字节 (int 占4字节 4*4=16)</span></span><br></pre></td></tr></table></figure><p>如果是空的编译器就不知道如何处理 如何得到后续地址</p><blockquote><p> size_t = long unsigned int 64位系统中 size_t = long long unsigned int</p></blockquote><p>声明指向多维数组的指针时 只能省略第一个方括号中的值, 第一对方括号用于表示这是一个指针…</p><h3 id="Variable-Length-Array-变长数组"><a href="#Variable-Length-Array-变长数组" class="headerlink" title="Variable Length Array - 变长数组"></a>Variable Length Array - 变长数组</h3><p>C的数组维数 必须是常量 , 不能使用变量来代替 </p><p>为了创建能处理任意大小的二维数组的函数  C99中添加了变长数组 , 允许使用变量表示数组的维度</p><p>‘变’指的是在创建数组的时候可以<code>使用变量表示数组维度</code> , 而非可以改变数组的大小</p><p>注意如果作为VLA变长数组的维度的参数(变量) 必须于VLA之前声明.</p><p>函数原型中的VLA参数名可以省略,但必须使用 <code>星号</code> 代替</p><h3 id="Function-Types-函数类型"><a href="#Function-Types-函数类型" class="headerlink" title="Function Types - 函数类型"></a>Function Types - 函数类型</h3><p>函数类型指的是函数的<code>返回值类型</code>,而非函数的参数类型</p><p>且不要搞混函数的<code>声明 declaration</code>和<code>定义 definition</code>, 函数声明是告知编译器函数的类型, 定义则是提供实际的代码</p><h3 id="⚔-Exercises-Pick-ur-weapon-and-face-it"><a href="#⚔-Exercises-Pick-ur-weapon-and-face-it" class="headerlink" title="⚔ Exercises - Pick ur weapon and face it."></a>⚔ Exercises - Pick ur weapon and face it.</h3><blockquote><p>实践是理论的基础，是理论的出发点和归宿点，对理论起决定作用，理论必须与实践紧密结合，理论必须接受实践的检验，为实践服务，随着实践的发展而发展。</p></blockquote><p>咳咳…就是些小练习…..</p><h4 id="Fibonacci-函数编写"><a href="#Fibonacci-函数编写" class="headerlink" title="Fibonacci() 函数编写"></a>Fibonacci() 函数编写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = fibonacci(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fibonacci 数列从第三项开始 , 每一项等于前两项之和 , 递归实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span> <span class="params">(<span class="keyword">int</span> count)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span> || count == <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(count<span class="number">-1</span>) + fibonacci(count - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">19</span>,<span class="number">97</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Running ...detecting %d elements in array.\nThe result after executing quickSort is: \n&quot;</span>,<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr));</span><br><span class="line">    </span><br><span class="line">    quickSort(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(*arr);i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d\n&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 设定中间值(亦称 &#x27;轴心点&#x27;) , 一般取数组中第一个值</span></span><br><span class="line"><span class="comment"> left  与 right  交替遍历 (递增递减操作 left++ right--) , </span></span><br><span class="line"><span class="comment"> 将 &lt; 轴心点的值 置于 左边 , &gt; 轴心点的值 置于 右边  , 相等的情况 不进行移动</span></span><br><span class="line"><span class="comment"> 遍历实现后 , 最后left与right 重合时的下标就是 基准值k ,  此时 轴心点实际值 下标即 k</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 此时以 k 为基准 , 其左边的值都小于它 , 右边的值都大于它</span></span><br><span class="line"><span class="comment"> 此时将存在 左右两个子序列  [start(0) - (k-1)] 和 [(k+1) - end] , 重复以上遍历方式即可. </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 可以使用递归实现 **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(start &lt; end) &#123;</span><br><span class="line">        <span class="comment">// 定义轴心点 \ 左右索引号</span></span><br><span class="line">        <span class="keyword">int</span> pivot = *arr,l = start,r = end<span class="number">-1</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历寻找 小于 轴心点的值 替换到左边 */</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot  ) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到符合条件的 r 值, 置于 pivot 左边 </span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="comment">// 注意 l 前置递增 先用再加 , 依旧从 l[0] 开始 </span></span><br><span class="line">                arr[l++] = arr[r];  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left 中 寻找第一个大于 轴心点的值 , 若非 , 则递增 l</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot  ) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l = r</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    </span><br><span class="line">    quickSort(arr,<span class="number">0</span>,l<span class="number">-1</span>);</span><br><span class="line">    quickSort(arr,l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mis mejores deseos</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell Step by Step</title>
      <link href="/2021/01/30/PowerShell-Step-by-Step/"/>
      <url>/2021/01/30/PowerShell-Step-by-Step/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><del>本文基于 <code>PowerShell 3.0</code> 发布</del><br>Windows是一个面向API的操作系统</p><h2 id="Getting-started-with-PowerShell"><a href="#Getting-started-with-PowerShell" class="headerlink" title="Getting started with PowerShell"></a>Getting started with PowerShell</h2><blockquote><p>一个脚本的平均寿命始于提示符，终结于字符</p></blockquote><p><code>Cmd + C# + .net = PowerShell</code></p><p> <code>cmdlets construction : Verb + Noun</code></p><p>分号<code>;</code>  可以使多条命令并行输出</p><h2 id="Help-System-in-PowerShell"><a href="#Help-System-in-PowerShell" class="headerlink" title="Help System in PowerShell"></a>Help System in PowerShell</h2><p>我们并不可能去牢记所有的命令，这不仅仅是存在的cmdlets太多的问题，除非真的可以记住它们(?。。。)<br>作为一名啃文档症重度患者，查看一件事物的帮助手册是一个很好的解决方案！<br>以下指令用以获取PowerShell cmdlets的官方文档.<br>  <i class="iconfont">&#xe61f; 语法：</i></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> [[-<span class="type">Name</span>] &lt;<span class="built_in">string</span>&gt;]  [&lt;<span class="type">CommonParameters</span>&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>The Parameter parameter displays only the descriptions of the specified parameters. If you specify only the asterisk (*) wildcard character, it displays the descriptions of all parameters. When Parameter specifies a parameter name such as GroupBy, information about that parameter is shown.</p></blockquote><p>当使用<code>星号（*）</code>通配符时，若为其指定参数名，ps将列出所有与它相关的 cmdlets：</p><p>e.g.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> *service*</span><br><span class="line"><span class="comment"># 它将列出前后包含 service 的相关 cmdlets</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-Help</span> g*service*</span><br><span class="line"><span class="comment"># 将列出以 g 开头并包含 service 的相关 cmdlets</span></span><br></pre></td></tr></table></figure><p>如果想列出某 cmdlet 的完整文档：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Help</span> [<span class="type">cmdlet</span>] <span class="literal">-Detailed</span></span><br><span class="line"><span class="comment"># Display more information for a cmdlet</span></span><br><span class="line"><span class="built_in">Get-Help</span> [<span class="type">cmdlet</span>] <span class="literal">-full</span></span><br><span class="line"><span class="comment"># full 的文档与 detailed 相似，更完整的内容对学习&#x27;管道&#x27;很有帮助</span></span><br></pre></td></tr></table></figure><p>对于一个cmdlet,使用<code> -example</code> 参数将显示所有官方给出相关实例。</p><p>为了防止工作流混乱，可以使用<code>-showwindow</code> 属性显示一个单独的帮助窗口来查看帮助文档。</p><p>关于帮助文档中的语法结构 ， 这里有一个概念 <code>位置参数</code> , 即在参数列表中已经固定位置，不需要再输入形参名来指定参数，直接输入传递参数即可，如以下代码示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> <span class="literal">-name</span> bits</span><br><span class="line"><span class="comment"># 这条指令可以简化为</span></span><br><span class="line"><span class="built_in">get-service</span> bits</span><br><span class="line">&amp;&amp; 利用别名那就更短了</span><br><span class="line"><span class="built_in">gsv</span> bits</span><br></pre></td></tr></table></figure><p>嘛，其实我还是更习惯在ms官网看这些文档，不过ps确实提供了一条捷径来获取这一帮助，更利于查找所需命令的文档，以下命令可以快速转到<code>线上文档</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">get-help</span> cmdlet <span class="literal">-online</span></span><br><span class="line"><span class="comment">#  -online 参数将跳转到在线帮助文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我永远喜欢巨硬.jpg</span></span><br></pre></td></tr></table></figure><hr><h2 id="Usage-of-pipeline"><a href="#Usage-of-pipeline" class="headerlink" title="Usage of pipeline"></a>Usage of pipeline</h2><p>Powershell 中的重要的概念 – <code>管道</code> , ….简单的说，一组命令中，输出的命令结果将<code>作为下一个命令的参数</code>执行，<br>e.g.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> | <span class="built_in">export-csv</span> <span class="literal">-path</span> F:\services.csv</span><br><span class="line"><span class="comment"># 这组命令将 获取所有服务 并 将其导出到 F盘 services.csv文件中</span></span><br></pre></td></tr></table></figure><p>将获取的数据导出到本地：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gal</span> | <span class="built_in">ConvertTo-Html</span> | <span class="built_in">Out-File</span> f:\Alias.html</span><br><span class="line"><span class="comment"># 这组命令将导出所有的别名及其所有属性到 Alias.html 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">gal</span> | <span class="built_in">ConvertTo-Html</span> <span class="literal">-Property</span> resolvedCommandname,displayname| <span class="built_in">Out-File</span> f:\Alias.html</span><br><span class="line"><span class="comment"># 这组命令将导出 存在resolvedCommandname,displayname属性的别名 到 F:\Alias.html 中</span></span><br></pre></td></tr></table></figure><div style="border-color: #FFB937; border-style: dotted none; border-width: 1px; text-align: center; font-size: 10px; color: #C88200; margin: 20px 0;" class="faa-float animated faa-slow">    ✏️ ———— 手动分割线 ——————</div>另外 ，.在使用管道进行命令组测试时，有时候我们并不清楚这条命令组将会带来的效应。比如输入以下命令组<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> | <span class="built_in">stop-service</span></span><br><span class="line"><span class="comment"># 你不会想执行这一命令组的。。！它将关闭所有的的服务.这可能会导致各种问题 ， 但 powershell 可不会告诉你这条命令安不安全</span></span><br><span class="line">(嗯。。 powershell 的 “自雷式”编程)</span><br></pre></td></tr></table></figure><p>所以使用类似这样的命令组之前，可以使用 <code>-whatif</code> 来测试，看看命令组究竟会进行哪些操作。<br>还可以使用 <code>-confirm</code> , 不过此参数是告诉 <code>某指令会怎么做(即指令目标target)</code> 和 <code>你是否要这样做</code> , 注意ps不会为你做出任何选择 </p><hr><h3 id="Pipeline-flow-control-cmdlet-“Where-Object-“"><a href="#Pipeline-flow-control-cmdlet-“Where-Object-“" class="headerlink" title="Pipeline flow control cmdlet “Where-Object “"></a>Pipeline flow control cmdlet “Where-Object “</h3><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-top:10px; margin-bottom:10px;"><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Docs</span><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/where-object?view=powershell-7.2#description" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Microsoft Docs</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Where-Object(Microsoft.PowerShell.Core)"</span></div><p><code>alias:</code> <code>?</code> ; <code>where</code></p><p><code>?</code> 是 <code>Where-Object</code>的别名，它还有另一个别名<code>where</code>  ， 主要用于<code>过滤列表项或输出结果</code></p><h3 id="Objects-for-PowerShell"><a href="#Objects-for-PowerShell" class="headerlink" title="Objects for PowerShell"></a>Objects for PowerShell</h3><p>先来看一组命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ps</span> | ? <span class="literal">-Property</span> handles <span class="operator">-gt</span> <span class="number">900</span> | <span class="built_in">sort</span> handles</span><br></pre></td></tr></table></figure><p>这组命令通过列出所有进程 并给到后面的管道处理 -&gt; 从属性handles中筛选出大于900的 -&gt; 以handles进行排序</p><p>这里能够使用属性，因为我们从<code>get-process (ps)</code>中得到的并不只是文本，实际是获取了一组对象，对象拥有属性和方法(老相识了)</p><p>可以使用<code>Get-Member(gm)</code> 查看有哪些属性或方法是可用的</p><p>使用<code>Select-Object(select)</code>来选择查看哪些属性</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gal</span> | <span class="built_in">select</span> Definition,Name</span><br><span class="line"><span class="comment"># 查看definition 和 name 属性 ， 即查看cmdlets 和 alias</span></span><br></pre></td></tr></table></figure><hr><h2 id="💡-Terminal-Solutions"><a href="#💡-Terminal-Solutions" class="headerlink" title="💡 Terminal Solutions"></a>💡 Terminal Solutions</h2><div class="note info"><p>此标题内容下将记录一些使用终端程序时发现的解决方案。</p></div><h3 id="于-Windows-Terminal-中使用-系统环境变量"><a href="#于-Windows-Terminal-中使用-系统环境变量" class="headerlink" title="于 Windows Terminal 中使用 系统环境变量"></a>于 Windows Terminal 中使用 系统环境变量</h3><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span><a href="https://github.com/microsoft/terminal/issues/7239" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">ISSUE #7239</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Environment changes are only picked up upon full restart"</span></div><div style="border-color: #FFB937; border-style: dotted none; border-width: 1px; text-align: center; font-size: 10px; color: #C88200; margin: 20px 0;" class="faa-float animated faa-slow">    ✏️ ———— 手动分割线 ——————</div><p>在添加完<code>环境变量</code>后使用Windows Terminal 时，使用<code>cd(Set-Location)</code>无法即时进入目录或打开程序，解决方案即将 Windows Terminal <code>重启</code>即可，访问设置的环境变量目录:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-Location</span> <span class="literal">-Path</span> <span class="variable">$env:SystemRoot</span></span><br></pre></td></tr></table></figure><p>此问题已在 #7239 添加<code>issue-Bug</code>标签，Merged issue 来自 <a href="https://github.com/microsoft/terminal/pull/7243">#7243</a></p><p>若是VSCode 或是 VS 中的终端，与上同理</p><h3 id="New-关于Windows-Terminal-中的权限提升"><a href="#New-关于Windows-Terminal-中的权限提升" class="headerlink" title="[New] 关于Windows Terminal 中的权限提升"></a>[New] 关于Windows Terminal 中的权限提升</h3><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span><a href="https://github.com/microsoft/terminal/issues/632" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">ISSUE #632</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Configuring Windows Terminal profile to always launch elevated"</span></div><p><strong>[Obsoleted]</strong>  <del>由于在一个未使用管理员模式的窗口中使用了一个拥有管理员权限的命令行…使应用程序存在安全漏洞，开发团队正在寻找一个安全的解决方案。</del></p><p>已经可以以管理员权限启动WT.</p><p>在体验Windows 11 期间 , 我发现<code>Windows Terminal V2.0</code>已经集成到 Windows 11 且成为默认终端.. <code>Win + x</code> 可见”Windows Terminal (Administrator)” </p><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;"><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Docs</span><a href="https://docs.microsoft.com/zh-cn/windows/terminal/" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Windows Terminal | Microsoft Docs</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Windows Terminal Overview"</span></div><br><p><strong>💡 几个小特性</strong></p><ul><li>若一个新的终端标签以权限提升启动,则其他存在的标签将转换为同等权限启动.</li><li>可以使用批处理文件来初始化终端的配置文件</li><li>从<a href="https://github.com/microsoft/terminal/releases/tag/v1.12.2922.0">Windows 终端预览版 v1.12.2922.0</a>开始,可以使用 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/customize-settings/startup#behavior-when-starting-a-new-terminal-session-preview">firstWindowPreference</a>全局设置关闭终端会话时保存窗口窗格布局</li></ul><h3 id="使用-PowerShell-添加永久的环境变量"><a href="#使用-PowerShell-添加永久的环境变量" class="headerlink" title="使用 PowerShell 添加永久的环境变量"></a>使用 PowerShell 添加永久的环境变量</h3><p><code>更改完毕后重启Windows Terminal 即可生效</code></p><p>基于.NET 5  <code>Environment</code>类中的 <code>SetEnvironmentVariable</code>方法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### Modify a system environment variable ###</span></span><br><span class="line">[<span class="type">Environment</span>]::SetEnvironmentVariable</span><br><span class="line">     (<span class="string">&quot;Path&quot;</span>, <span class="variable">$env:Path</span>, [<span class="type">System.EnvironmentVariableTarget</span>]::Machine)</span><br></pre></td></tr></table></figure><h4 id="SetEnvironmentVariable-String-String-EnvironmentVariableTarget-重载"><a href="#SetEnvironmentVariable-String-String-EnvironmentVariableTarget-重载" class="headerlink" title="SetEnvironmentVariable(String, String, EnvironmentVariableTarget) - 重载 -"></a>SetEnvironmentVariable(String, String, EnvironmentVariableTarget) - 重载 -</h4><p>创建、修改或删除当前进程中或者为当前用户或本地计算机保留的 Windows 操作系统注册表项中存储的环境变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetEnvironmentVariable</span> (<span class="params"><span class="keyword">string</span> variable, <span class="keyword">string</span>? <span class="keyword">value</span>, EnvironmentVariableTarget target</span>)</span>;</span><br></pre></td></tr></table></figure><div style="overflow: hidden; margin-bottom: 10px;"><span style="font-weight: 600; font-size: 12px; background-color: #f2f2f2; color: #585858; padding:0 6px 2px; line-height: 160%; font-family: sans-serif;">variable</span><span style="text-decoration: none; font-size: 14px; font-family: Georgia, serif; ">String</span><span style="display: block; margin: 5px 0px 0px 4px;font-size: 14px; ">环境变量名。</span></div><div style="overflow: hidden; margin-bottom: 10px;"><span style="font-weight: 600; font-size: 12px; background-color: #f2f2f2; color: #585858; padding:0 6px 2px; line-height: 160%; font-family: sans-serif;">value</span><span style="text-decoration: none; font-size: 14px; font-family: Georgia, serif; ">String</span><span style="display: block; margin: 5px 0px 0px 4px;font-size: 14px; ">要分配给<span style="font-size: 12px; background-color: #f2f2f2; font-family: sans-serif;">variable</span>的值</span></div><div style="overflow: hidden; margin-bottom: 10px;"><span style="font-weight: 600; font-size: 12px; background-color: #f2f2f2; color: #585858; padding:0 6px 2px; line-height: 160%; font-family: sans-serif;">target</span><span style="text-decoration: none; font-size: 14px; font-family: Georgia, serif; ">EnvironmentVariableTarget</span><span style="display: block; margin: 5px 0px 0px 4px;font-size: 14px; ">一个用于指定环境变量的位置的枚举值。</span></div><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Docs</span><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.environment.setenvironmentvariable?view=net-5.0#System_Environment_SetEnvironmentVariable_System_String_System_String_System_EnvironmentVariableTarget_" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Microsoft Docs</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Environment.SetEnvironmentVariable 方法 (System)"</span></div><hr><h2 id="🎁-Instances-IN-Practices"><a href="#🎁-Instances-IN-Practices" class="headerlink" title="🎁 Instances IN Practices"></a>🎁 Instances IN Practices</h2><h3 id="Get-process-ID-though-port-which-was-occupied"><a href="#Get-process-ID-though-port-which-was-occupied" class="headerlink" title="Get process ID though port which was occupied"></a>Get process ID though port which was occupied</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-NetTCPConnection</span> <span class="literal">-LocalPort</span> <span class="number">443</span> | <span class="built_in">ft</span> LocalPort,OwningProcess</span><br></pre></td></tr></table></figure><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-top:10px; margin-bottom:10px;"><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Docs</span><a href="https://docs.microsoft.com/zh-cn/powershell/module/nettcpip/get-nettcpconnection?view=winserver2012r2-ps&redirectedfrom=MSDN#examples" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Microsoft Docs</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Get-NetTCPConnection(NetTCPIP)"</span></div><p>以上命令将获取占用<code>443端口</code>的<code>PID</code></p><p>通过<code>pipeline</code>传递给<code>ft</code>,将所选属性的结果以表格形式输出</p><p><code>ft</code> =&gt; <code>Format-Table</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习笔记</title>
      <link href="/2020/12/11/HtmlNote/"/>
      <url>/2020/12/11/HtmlNote/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info"><p>今天写着某实例，突然想起还有这个暂存的笔记·····啊··鸽了<br>那就重新开始更新吧！  <a href="#_position" style="text-decoration: none;">跳转到</a></p></div><h3 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h3><p>使用vscode进行代码编写，推荐使用以下插件！</p><ul><li><code>open in browser</code> - 右键添加在浏览器中打开项目</li><li><code>Auto Rename Tag </code>- 自动重命名HTML + Xml 标签</li><li><code>JS-CSS-HTML Formatter </code>- 格式化代码</li></ul><h3 id="标签语义"><a href="#标签语义" class="headerlink" title="标签语义"></a>标签语义</h3><p><code>&lt;!DOCTYPE&gt;</code>标签 ： 文档类型声明标签</p><p><code>&lt;html lang=&quot;zh-CN&quot;&gt;</code> 浏览器根据其内容识别是何种语言网站，此处为中文，将采取中文来显示</p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 字符集 ，此处采取utf-8存储文字信息，必须写 否则乱码</p><blockquote><p>以上三条语句在vscode中均会自动生成，需理解其作用</p></blockquote><hr><p><i id="_position"></i></p><div class="note success"><p>重新开始更新，过去一些内容已经删除了，仅记录个人学习中的一些经历····,实践中发现的小技巧，关于标签使用的内容手动查询文档即可</p></div><hr><h3 id="CSS游历记"><a href="#CSS游历记" class="headerlink" title="CSS游历记"></a>CSS游历记</h3><h4 id="关于伪元素before-amp-after-的显示方式"><a href="#关于伪元素before-amp-after-的显示方式" class="headerlink" title="关于伪元素before &amp; after 的显示方式"></a>关于伪元素before &amp; after 的显示方式</h4><p>图上元素(li为父元素)右上角的 ‘减’ 就是使用伪元素实现的 需要添加到另一个li的时候只需要加入一个类名即可 ,这样子就不需要在html中添加其他的元素了<br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/08/21/qHiQJFK56ubGvcU.png" alt="beforeAfter.png"><br>实例得<code>::before</code> 将位于 <code>::after</code>的下层<br>由此使用before伪元素制作下层的三角边框,after伪元素作为文字层即可<br>e.g.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.recommend</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">6px</span> <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="number">#589d5a</span> <span class="number">#589d5a</span> transparent <span class="number">#589d5a</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.recommend</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;减&#x27;</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="border-color: #FFB937; border-style: dotted none; border-width: 1px; text-align: center; font-size: 10px; color: #C88200; margin:20px 0;" class="faa-float animated faa-slow">    ✏️ ———— 手动分割线 —————— </div><h4 id="BFC-与外边距-margin-塌陷问题"><a href="#BFC-与外边距-margin-塌陷问题" class="headerlink" title="BFC 与外边距(margin)塌陷问题"></a>BFC 与外边距(margin)塌陷问题</h4><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="#" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Zhihu </a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"CSS中外边距（margin）塌陷和合并的问题"</span></div><h3 id="🥰-个人练习样式-记录-✨"><a href="#🥰-个人练习样式-记录-✨" class="headerlink" title="🥰 个人练习样式 记录 ✨"></a>🥰 个人练习样式 记录 ✨</h3><div class="note success"><p>这里将记录我自己写的一些样式！欢迎交流学习，发在博客的基本都是使用的CSS<code>行内样式表</code>, 可能写得不是很好，·····嘛，其实自己觉得还是蛮好看的啦😂,以后整好了pug [ 说实话挺需要这类教程的 ] 会加进预设标签内，到时就可以直接使用啦。呃···名称什么的，随便取的😝···· 随缘更新吧</p></div><div style="text-align: center;"><span style="background-color:rgba(14, 139, 211,.7); color: #fff; padding: 4px 10px;  width: 200px; ">✨  可跳转式类标签&nbsp;&nbsp;还有个动效的不过和博客不适配=.=</span><div style="margin:5px 0; ">👇</div></div><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Title</span><a href="#" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Link #0001</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"这里填写内容"</span></div><hr><div style="text-align: center;"><span style="background-color:rgba(14, 139, 211,.7); color: #fff; padding: 4px 10px;  width: 200px; ">✨  描述式按钮&nbsp;&nbsp;</span><div style="margin:5px 0; ">👇</div></div><div style="text-align: center; "><a href="#"><div style="display: inline-block; box-shadow:  0 0 4px rgba(0, 0, 0, .3);">    <span style="display: inline-block; color: white; font-family: Microsoft YaHei ; font-size: 12px; background: #0078E7; padding:5px 10px;">✍️ Title</span>    <span style="display: inline-block; color: #5F5F5F; font-family: Microsoft YaHei; font-size: 12px; padding:4px 10px;border:1px solid #0078E7; margin-left: -5px; ">Link desc</span></div></a></div><h2 id="JavaScript-笔记"><a href="#JavaScript-笔记" class="headerlink" title="JavaScript 笔记"></a>JavaScript 笔记</h2><p><code>ECMAScript \ DOM \ BOM</code></p><h3 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h3><ul><li><p><code>数组</code> - 在<code>Javascript</code>中,数组中的数组元素的数据类型不受约束,可以是任意类型.<br>和其他多数编程语言一样,index总是从0开始<br>JS中追加数组元素的方式 可以直接通过<code>修改索引号</code>实现, 在循环中可以直接使用 <code>arrary.length;</code> 来实现不断往后添加新元素</p></li><li><p><code>函数</code>返回一个结果,如果想返回多个值可以利用数组,如果函数无返回值,则返回<code>undefined</code><br>对比break和continue ,<code>return</code>不仅可以退出循环,还可以结束函数.</p></li></ul><p><code>Arguments 对象</code> 以<code>伪数组</code>的形式展现.存储了传递到函数的所有实参.<br> [126] 伪数组并非真正意义上的数组</p><ul><li>伪数组不具有数组的<code>length属性</code></li><li>按照索引的方式存储</li><li>没有数组的一些方法 pop() push() 等…</li></ul><p>函数的另一种声明方法 -  <code>函数表达式(匿名函数)</code> </p><p>内部函数访问外部函数的变量采用<code>链式查找</code>的方式决定取值 , 此结构即<code>作用域链</code> - 遵循就近原则</p><ul><li>JavaScript 的预解析 , 浏览器会预先解析<code>function</code> 和 <code>var</code>, 将其声明或定义提升到当前作用域的顶部(除了变量的定义.) ,</li></ul><h4 id="关于数组操作"><a href="#关于数组操作" class="headerlink" title="关于数组操作"></a>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">数组</a>操作</h4><ul><li><h5 id="添加或删除数组元素"><a href="#添加或删除数组元素" class="headerlink" title="添加或删除数组元素"></a>添加或删除数组元素</h5><ul><li><code>Array.unshift()</code>方法,在数组头部插入一个新元素</li><li><code>Array.push()</code>,在数组末尾追加一个新元素</li><li><code>Array.pop()</code>,删除数组中最后一个元素</li><li><code>Array.shift()</code>,删除数组中第一个元素</li></ul></li></ul><p>这些方法都会改变原数组长度, 且<code>pop()</code>与<code>shift()</code>存在返回值,将返回被删除的那个数组元素.</p><p>不太一样的方法:</p><p><code>array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code>方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p><ul><li><p>翻转数组</p><ul><li><code>Array.reverse();</code>方法将翻转数组,改变了数组，并返回该数组的引用。</li></ul></li></ul><ul><li><p>数组元素获取</p><ul><li><code>arr.indexOf(searchElement[, fromIndex])</code>获取指定首个元素的索引号,第二个参数可选,指定开始查找的位置.</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重案例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldArr = [<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="comment">// indexOf() 注意大小写</span></span><br><span class="line"><span class="comment">// 方法1 : </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delDuplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempArr = arr;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> a = <span class="number">0</span>; a&lt; tempArr.length; a++) &#123;</span><br><span class="line">        <span class="keyword">var</span> first = tempArr.indexOf(tempArr[a]);</span><br><span class="line">        <span class="keyword">var</span> sec = tempArr.lastIndexOf(tempArr[a]);</span><br><span class="line">        <span class="keyword">if</span> (first != sec) &#123;</span><br><span class="line">            tempArr.splice(a,<span class="number">1</span>);</span><br><span class="line">            delDuplicate(tempArr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(delDuplicate(oldArr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法 2 (来自pink老师) :</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newArr.indexOf(arr[i] == <span class="number">-1</span>)) &#123; <span class="comment">// 若不存在,则插入元素</span></span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(oldArr));</span><br></pre></td></tr></table></figure><ul><li><p>数组转字符串</p><ul><li><code>toString()</code>方法将数组转换为字符串</li><li><code>arr.join([separator])</code>方法,将数组转换为字符串并可以选择为其添加分隔符</li></ul></li></ul><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">字符串</a>对象</h3><p>字符串的字面量即 <code>单引号</code> 和<code>双引号</code></p><p>字符出现次数实例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;abcoefoxyozzopp&quot;</span>;</span><br><span class="line"><span class="comment">// 方法1:</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> allIndex = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIndex</span>(<span class="params">date,target,start</span>) </span>&#123;</span><br><span class="line">    i = date.indexOf(target,start);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        allIndex.push(i);</span><br><span class="line">        getIndex(date,target,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getIndex(string,<span class="string">&#x27;o&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;出现的次数是&quot;</span> + count + <span class="string">&#x27;\n其索引号分别为:&#x27;</span> + allIndex);</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 (来自pink老师) 噗我写好像比较复杂.. // :</span></span><br><span class="line"><span class="keyword">var</span> index = string.indexOf(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(index!=<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    num++;</span><br><span class="line">    index = string.indexOf(<span class="string">&#x27;o&#x27;</span>,index+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;o出现的次数是&#x27;</span> + num);</span><br></pre></td></tr></table></figure><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><p>可以像数组那样访问字符串字符,每个字符对应一个索引</p><ul><li><code>str.charAt(index)</code>方法从一个字符串中返回指定的字符。</li><li><code>str.charCodeAt(index)</code>方法返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的 UTF-16 代码单元</li></ul><h4 id="拼接及截取字符串"><a href="#拼接及截取字符串" class="headerlink" title="拼接及截取字符串"></a>拼接及截取字符串</h4><ul><li><code>str.concat(str2, [, ...strN])</code>方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。(强烈建议使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators">赋值操作符</a>（<code>+</code>, <code>+=</code>）代替 <code>concat</code> 方法。)</li><li><code>str.substring(indexStart[, indexEnd])</code>方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</li></ul><h4 id="其他一些方法"><a href="#其他一些方法" class="headerlink" title="其他一些方法"></a>其他一些方法</h4><ul><li><p><code>str.replace(regexp|substr, newSubStr|function)</code>方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。模式可以是一个字符串或者一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。<strong>如果<code>pattern</code>是字符串，则仅替换第一个匹配项。</strong></p><p>原字符串不会改变。</p></li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li>JavaScript 创建对象 : </li><li><ul><li>可以利用字面量创建对象 , 即 <code>&#123;&#125; 大括号</code> , 嗯….<code>属性</code>采用键值对的形式,与python的字典较为相似,方法的写法利用匿名函数. 多个属性与方法之间用逗号隔开,最后一个不用写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    age:<span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">    sex:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以这样调用属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种创建对象的方法 new (跟c#一样..):</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 随后可以在后面追加属性</span></span><br><span class="line">obj.name = <span class="string">&#x27;TinyStar&#x27;</span>;</span><br><span class="line">obj.age = <span class="string">&#x27;18&#x27;</span>;</span><br><span class="line">obj.sex = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"><span class="comment">// 追加方法也是如此</span></span><br><span class="line">obj.SayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>与’类’相似,访问对象属性直接 <code>obj.propName</code> , 方法 <code>obj.funcName()</code></li></ul></li></ul><h4 id="JavaScript中的构造函数"><a href="#JavaScript中的构造函数" class="headerlink" title="JavaScript中的构造函数"></a>JavaScript中的构造函数</h4><p>总体与’类’相似….无需返回值 , 返回object</p><p>利用构造函数来处理具有相同属性或方法的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本语法格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConstructorName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.prep = value;</span><br><span class="line">    <span class="built_in">this</span>.Method = funciton () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> ConstructorName(); <span class="comment">// call</span></span><br></pre></td></tr></table></figure><p>访问对其内部属性和方法格式即对对象的访问方式</p><h4 id="利用-for-…-in-b遍历对象"><a href="#利用-for-…-in-b遍历对象" class="headerlink" title="利用 for … in  b遍历对象"></a>利用 for … in  b遍历对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    age:<span class="string">&#x27;17&#x27;</span>,</span><br><span class="line">    sex:<span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    fn:fuction () &#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 输出属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[i]); <span class="comment">// 输出属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript-的标准内置对象"><a href="#JavaScript-的标准内置对象" class="headerlink" title="JavaScript 的标准内置对象"></a>JavaScript 的标准内置对象</h4><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">JavaScript | MDN</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"标准内置对象"</span></div><h4 id="JavaScript中的原型和原型链"><a href="#JavaScript中的原型和原型链" class="headerlink" title="JavaScript中的原型和原型链"></a>JavaScript中的原型和原型链</h4><p>…..个人感觉这个标题下内容 和 OOP中的基类和继承链的关系相似…</p><blockquote><p>原型链是实现继承的主要方法。 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个prototype属性，指向原型对象。 原型对象都包含一个指向构造函数的指针（constructor）。</p></blockquote><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:10px; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">JavaScript | MDN</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"对象原型"</span></div><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="https://zhuanlan.zhihu.com/p/62903507" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">知乎</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"JavaScript中的原型与原型链"</span></div>---<h4 id="简单数据类型和复杂数据类型"><a href="#简单数据类型和复杂数据类型" class="headerlink" title="简单数据类型和复杂数据类型"></a>简单数据类型和复杂数据类型</h4><p>相当于值类型和引用类型</p><p>简单数据类型存储在栈中,作为参数传递时传递的是数据的拷贝,不会被改变值, </p><p>复杂数据类型存放在堆<code>Heap</code>中</p><h3 id="WebAPIs"><a href="#WebAPIs" class="headerlink" title="WebAPIs"></a>WebAPIs</h3><p><code>Web API</code>是浏览器提供的一套操作<code>浏览器功能(BOM - browser object model)</code>和<code>页面元素(DOM - document object model)</code>的API</p><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><p><img src= "/img/loading.gif" data-lazy-src="https://tse3-mm.cn.bing.net/th/id/OIP-C.jT5hS8c0Snf9Mu7UsSdJHgHaED?w=318&h=180&c=7&r=0&o=5&pid=1.7"></p><ul><li><code>文档</code> 一个页面就是一个文档,DOM中使用<code>document</code>表示</li><li><code>元素</code> 页面中的所有标签都是元素,DOM中使用<code>element</code>表示</li><li><code>节点</code> 网页的所有内容都是节点(标签|属性|文本|注释等),DOM中使用node表示</li></ul><hr><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><p>根据ID获取,使用<code>getElementById()</code>方法,此方法返回一个<code>element对象</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(id);    </span><br></pre></td></tr></table></figure><p>获取一类标签元素 , 可使用<code>getElementsByTagName()</code>方法,将返回一个动态的HTML集合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCollection"><code>HTMLCollection</code></a>,其以伪数组的方式存储,这代表着它可以被遍历,若查找的元素根本不存在,则返回一个空的伪数组,且其length属性为0</p><p>注意父元素必须为单个元素对象,获取的时候不包括父元素自身.</p><p><code>Document</code> 接口表示任何在浏览器中载入的网页，并作为网页内容的入口，也就是<a href="https://developer.mozilla.org/en-?US/docs/Using_the_W3C_DOM_Level_1_Core">DOM 树</a>。DOM 树包含了像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body"><body></a> 、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table"><table></a>这样的元素，以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">大量其他元素</a>。它向网页文档本身提供了全局操作功能，能解决如何获取页面的 URL ，如何在文档中创建一个新的元素这样的问题。</p><hr><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">MDN</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Document - WebApI接口参考"</span></div>---<h5 id="特殊元素获取"><a href="#特殊元素获取" class="headerlink" title="特殊元素获取"></a>特殊元素获取</h5><ul><li><code>&lt;body&gt;</code>: 使用语句 <code>document.body</code></li><li><code>&lt;html&gt;</code>: 使用语句 <code>document.documentElement</code></li></ul><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件三要素:</p><ul><li>事件源: 触发事件的对象</li><li>事件类型: 如何触发 如:鼠标点击 \ 键盘按下某键</li><li>事件处理程序: 通过函数赋值的方式完成</li></ul><p>执行事件的步骤:</p><ul><li>获取事件源</li><li>注册事件 / 绑定事件</li><li>添加事件处理程序 / 采用匿名函数</li></ul><h5 id="事件的冒泡与捕获及其阻止"><a href="#事件的冒泡与捕获及其阻止" class="headerlink" title="事件的冒泡与捕获及其阻止"></a>事件的冒泡与捕获及其阻止</h5><blockquote><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p></blockquote><p>🔖 简单来说 事件冒泡将从最内层元素开始发生 , 一直向上传播 直到 document对象<br>事件捕获则相反 , 从document对象开始,直到具体的元素.</p><div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; "><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Ref</span><a href="https://www.cnblogs.com/zhuzhenwei918/p/6139880.html" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">JavaScript事件传播</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"JavaScript中捕获/阻止捕获、冒泡/阻止冒泡"</span></div><p>有关函数:</p><ul><li><code>event.preventDefault();</code></li><li><code>event.stopPropagation()</code></li><li><code>event.stopImmediatePropagation()</code></li></ul><h4 id="关于H5自定义属性"><a href="#关于H5自定义属性" class="headerlink" title="关于H5自定义属性"></a>关于H5自定义属性</h4><p>H5规定自定义属性以  <code>data-</code> 开头作为名并为其赋值</p><p>例如 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-index</span> = <span class="string">&#x27;1&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用自定义属性保存并使用某些数据,就不用将它们存入数据库中了.</p><p>使用 <code>Element.getAttribute()</code> 和 <code>Element.setAttribute()</code>来操作它们</p><p>注意利用属性操作元素的样式的时候,操作的是它们的 <code>style</code>属性,虽然和这个标题无关,但是今天确实是犯了与其相关的低级错误.</p><h4 id="H5新增的获取自定义属性的方法"><a href="#H5新增的获取自定义属性的方法" class="headerlink" title="H5新增的获取自定义属性的方法"></a>H5新增的获取自定义属性的方法</h4><p>针对基于标准属性 以<code>data-</code>开头的自定义属性,可以使用</p><p><code>Element.dataset.Name</code> &amp;&amp;</p><p><code>Element.dataset[Name]</code></p><p>访问已存在的自定义属性</p><p>若自定义属性名有多个<code>-</code>链接单词,则获取的时候可以使用<code>驼峰命名法</code></p><p><code>Element.dataset[dataFirstIndex]</code></p><h4 id="JS执行机制-Event-loop"><a href="#JS执行机制-Event-loop" class="headerlink" title="JS执行机制(Event loop)"></a>JS执行机制(Event loop)</h4><p>js为<code>单线程</code>语言</p><p>同步任务都在主线程上执行, 形成一个<code>执行栈</code></p><p>JS的异步是通过<code>回调函数</code>来实现的 , 异步任务相关的回调函数将添加到<code>任务队列(消息队列)</code>中</p><p>在主线程执行栈中发现带有回调函数的任务时则将其插入到任务队列的末尾,主程序执行栈执行完毕后再将任务队列中的任务取到执行栈尾部执行.</p><h5 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h5><h4 id="Location-对象-Window-Location"><a href="#Location-对象-Window-Location" class="headerlink" title="Location 对象 (Window.Location)"></a>Location 对象 (Window.Location)</h4><p>了解一下这些….</p><p>URL 语法 :<code>protocol://host[:port]/path/[?query]#fragment</code></p><p><code>URI (uniform resource identifier) 统一资源标识符</code>通过两种<code>方式</code>进行资源表示</p><ul><li><code>URL (uniform resource locator) 统一资源定位符</code></li><li><code>URN (uniform resource name) 统一资源命名符</code></li></ul><p>URN在理论上来说较为完美,但其实现所需要的解析器难以构建,使得当前URI主要的标识方式为<code>URL</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序逻辑分离与事件处理</title>
      <link href="/2020/11/23/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2020/11/23/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p> chap. 20 这里结束后应该就可以开发新功能了嘻嘻，这一部分花了挺长时间的…</p></blockquote><p>事件处理大致分为: 声明委托、声明事件、订阅事件、触发事件 </p><h3 id="委托的声明"><a href="#委托的声明" class="headerlink" title="委托的声明"></a>委托的声明</h3><blockquote><p>委托类似于 C/C++中的函数指针</p></blockquote><p>委托，可以从字面意思来理解它——这儿有一件事情，但是我不去亲自完成它，而是把它交给其他对象去做。我不过是间接参与了这件事的完成。</p><p>在C#的类库中提供了大量的委托类型，举例以下，包括其泛型版本:</p><h4 id="Action-委托"><a href="#Action-委托" class="headerlink" title="Action 委托"></a>Action 委托</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 泛型版本：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;    <span class="comment">// 无返回值</span></span><br></pre></td></tr></table></figure><p>这是<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.action?view=net-5.0">Action</a>委托，提示<code>Action(void() target)</code></p><p>封装的方法必须对应于由此委托定义的方法签名，所以这意味着封装的方法必须没有任何参数，并且不能有返回值。</p><p>以下代码合法，且属于间接调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">      Action action = <span class="keyword">new</span> Action(calculator.Report);</span><br><span class="line">      action(); <span class="comment">// 简写（函数指针式写法）完整形式为：action.Invoke();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is a method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="Func-lt-T-gt-委托"><a href="#Func-lt-T-gt-委托" class="headerlink" title="Func&lt;T&gt;委托"></a>Func&lt;T&gt;委托</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T</span>,<span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T arg</span>)</span>;</span><br></pre></td></tr></table></figure><p>这是<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.func-2?view=net-5.0">Func&lt;T&gt;</a>委托，我一看····哦！ 是个泛型委托，总共可提供17个参数 （16 个类型参数(表示目标方法的参数类型)，1个返回类型··</p><p>以上Calculator类添加方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a,<span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要以委托调用Add与Sub方法，可以使用Func&lt;T&gt;委托</p><p>Main方法中添加以下代码合法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; func = <span class="keyword">new</span> Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(calculator.Add);</span><br><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; funcSub = <span class="keyword">new</span> Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(calculator.Sub);</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>; <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">result =  func.Invoke(a,b);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line">result = funcSub.Invoke(a, b);</span><br><span class="line">Console.WriteLine(result);</span><br></pre></td></tr></table></figure><p>这里的Func&lt;T&gt;委托如 ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; func = <span class="keyword">new</span> Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(calculator.Add);</span><br></pre></td></tr></table></figure><p>即表示获取三个参数，目标方法提供2个int参数值，且返回值也为int类型，所以与前面写到的Add与Sub方法能保持<strong>类型兼容</strong>。（签名并不需要完全一致</p><p>··· 和Action委托很直观的区别就是<strong>有无返回值</strong></p><h4 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h4><p>委托属于一种类(class 引用类型) ,声明在命名空间体中（虽然可以以嵌套的方式声明在其他类中·····调用的时候需要附带上层类名），使用<code>delegate</code>关键字<strong>声明委托</strong>类型，例如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">myDelegat</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure><p>像这一个委托，其要求目标方法提供2个int参数值，且返回类型也为int，这即是我们对目标方法的<strong>类型约束</strong>。</p><p>调用委托的方法和调用方法的语法一致，属于间接调用。</p><h4 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h4><blockquote><p>把方法作为参数传递给另外一个方法</p></blockquote><p>作为<strong>模板方法</strong>：</p><p>委托具有返回值，一般把委托作为方法参数传入方法，另一方法间接调用被委托封装的方法。即“另一个方法” “借用”指定的外部方法来产生结果。(👋 Hey····嗯？难理解嘛？看下图 👇</p><div align="center">    <img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/freexmelody/cdn@master/imgGo/delegateDoc.png" width="50%" style="box-shadow: 0px 0px 20px -10px #888"></div> 回调（callback）方法(又称好莱坞方法、面试方法:<p>有选择的去调用一个方法， 使用时需要把委托类型的参数传入主调方法，此委托的参数被封装一个回调方法，</p><p>回调方法一般无返回值</p><h4 id="委托的高级使用"><a href="#委托的高级使用" class="headerlink" title="委托的高级使用"></a>委托的高级使用</h4><ul><li><p>多播委托( multicast ) </p><ul><li>属于同步调用</li></ul></li><li><p>隐式异步调用</p><ul><li><p>同步异步理解（中英文上的语言差异）：</p><ul><li><p>同步：你做完了，我（在你的基础上）接着做</p></li><li><p>异步：咱俩同时做</p></li></ul></li><li><p>同步调用和异步调用区别：</p><ul><li>每一个运行的程序就是一个<strong>进程</strong>(process)</li><li>每个进程可以有多个<strong>线程</strong>(thread)（第一个线程即是主线程）</li><li>同步调用在同一线程内</li></ul></li></ul></li></ul><p>所以也可以这样去理解：串行==同步==单线程 ，并行==异步==多线程（异步的底层机理就是<strong>多线程</strong>）</p><p>委托的调用有<strong>BeginInvoke</strong>()方法，这属于一个<strong>隐式异步调用</strong>，</p><blockquote><p>第一个参数是一个 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.asynccallback">AsyncCallback</a> 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象，该对象将信息传递到回调方法。 <code>BeginInvoke</code> 将立即返回，而不会等待异步调用完成。</p></blockquote><p>异步调用中，多个线程的执行会抢占资源而导致冲突，为避免此冲突需要为线程加锁。</p><p><strong>显式的异步调用</strong>可以使用thread | task</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Task</span>&lt;<span class="title">TResult</span>&gt; : <span class="title">System.Threading.Tasks.Task</span></span><br><span class="line"></span><br><span class="line"><span class="title">public</span> <span class="title">sealed</span> <span class="keyword">class</span> <span class="title">Thread</span> : <span class="title">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</span></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><div align="center">    <img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/freexmelody/cdn@master/imgGo/EventImg.png" alt="我滴Mind Map，主要展示事件模型" width="50%" style="box-shadow: 0px 0px 20px -10px #888"></div><p>事件不会自行发生，这对于订阅者来说就是一个工具，</p><p>事件的声明很简单，只需要再委托前加上<code>event</code>关键字，最后跟上事件名称即可.</p><p><strong>命名约定：</strong></p><p>如果一个委托是为声明事件准备的，根据.Net的约定，应以<code>EventHandler</code>作为委托的结尾。（用于存储事件处理器）。</p><p>如果一个类作为事件数据/参数传递，根据.Net的约定，应以<code>EventArgs</code>结尾。</p><p>用于触发事件的方法一般命名为 <code>On + 事件名称</code> ，且其访问级别为 <code>protected</code> 而非 public</p><h4 id="事件的订阅"><a href="#事件的订阅" class="headerlink" title="事件的订阅"></a>事件的订阅</h4><p>事件只能作用于+=和-=操作符的左边（要么添加事件处理器，要么移除…）</p><p>使用new操作符创建委托实例，与事件关联，使用<code>+=</code>操作符添加事件处理器</p><p><strong>订阅者【事件处理器】之间不会相互干扰</strong></p><p>取消订阅事件，向事件注销：</p><p>将与事件关联的委托实例，使用<code>-=</code>操作符，删除事件处理器。</p><p> 在事件内部中，编译器会把 <code>+=</code>和<code>-=</code>操作符翻译成调用add或remove访问器，这也是其底层原理。</p><p><em>分析一下窗体设计器中生成的事件吧：</em></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click_1</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个是双击控件button1后自动创建的事件，默认存在一个引用，即订阅事件 由button1订阅  订阅代码生成在Form1.Designer.cs</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// Designer source code : </span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">new</span> System.EventHandler(<span class="keyword">this</span>.button1_Click_1);</span><br><span class="line">        <span class="comment">// 这边使用了一个EventHandle委托，  Microsoft Document说明如下： </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="keyword">object</span>? sender, EventArgs e</span>)</span>;</span><br><span class="line">        <span class="comment">//实际上也可以这么写（直接附上方法名）： </span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">this</span>.button1_Click_1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#x27;sender&#x27;Object:事件源</span></span><br><span class="line"><span class="comment">  &#x27;e&#x27;EventArgs:不包含事件数据的对象</span></span><br><span class="line"><span class="comment">  继承 Object -&gt; Delegate -&gt; EventHandle  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有其他的订阅方式  挂接事件处理</span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += <span class="keyword">delegate</span>(<span class="keyword">object</span> sender,EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.textBox1.text=<span class="string">&quot;hah,这其实就是一个 匿名委托 &quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不过上面这个写法已经过时了 ， 取代的是使用lambda表达式的写法</span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += (<span class="keyword">object</span> sender,EventArgs e) =&gt;&#123;</span><br><span class="line">    <span class="keyword">this</span>.textBox1.Text = <span class="string">&quot;应该使用lambda表达式写&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 甚至可以这么写</span></span><br><span class="line"><span class="keyword">this</span>.button1.Click += (sender,e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">this</span>.textBox1.Text = <span class="string">&quot;hah&quot;</span>;</span><br><span class="line">&#125;; <span class="comment">// 编译器将根据委托的约束自动判断事件参数是何种数据类型</span></span><br></pre></td></tr></table></figure><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><div class="note info"><p>2020 / 12 / 8  更新</p></div><p>以上直接使用委托与 event 关键字、+= -=操作符的做法属于事件的简略声明（也叫字段式声明）</p><p>实际可以直接通过委托字段来进行订阅事件这一环节。event关键字的存在让程序的逻辑更加安全，其本身相当于委托的<code>包装器</code>，该包装器对委托字段的访问起到<code>限制作用</code>，相当于一个蒙版,它对外界隐藏了委托实例的大部分功能（Invoke、MethodInfo、ObjectInfo等）。仅暴露出订阅（+=）和去除订阅（-=）的功能，保护了委托不被人滥用。 —————— 相当于OOP中**封装(encapsulation)**的概念，其一个重要的功能就是隐藏。</p><h5 id="事件和委托的关系"><a href="#事件和委托的关系" class="headerlink" title="事件和委托的关系"></a>事件和委托的关系</h5><p>事件不是“以特殊方式声明的委托实例/字段”</p><p>为什么要使用委托类型来声明事件：</p><ul><li>从Source的角度来看的话：为了表明Souce能对外传递哪些消息</li><li>从Subscriber的角度来看：这是一种约定，为了约束能使用什么样签名的方法来处理事件</li><li>委托类型的实例将用于存储（或引用）事件处理器</li></ul><h5 id="事件与属性的关系"><a href="#事件与属性的关系" class="headerlink" title="事件与属性的关系"></a>事件与属性的关系</h5><p>属性不是字段，多数时候属性是字段的包装器，用来保护字段不会被滥用。</p><p>事件不是委托字段，且事件是委托字段的包装器，其保护委托字段不被滥用。</p><p>包装器永远不会被包装。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>委托最好声明在命名空间体内</li><li>委托定义，目标方法必须与委托保证类型兼容</li><li>适时的使用接口来取代对委托的使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法参考...</title>
      <link href="/2020/10/26/MarkDown%20grammar/"/>
      <url>/2020/10/26/MarkDown%20grammar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># page title level 1 #</span><br><span class="line">## page title level 2 ##</span><br><span class="line">### page title level 3 ###</span><br><span class="line">#### page ....level 4 ####</span><br><span class="line">##### level 5 more than 6...下面就不写了 顶多六级标题 ##</span><br></pre></td></tr></table></figure><h3 id="指定标题ID"><a href="#指定标题ID" class="headerlink" title="指定标题ID"></a>指定标题ID</h3><p>一些 Markdown 引擎支持为标题指定 ID，另一些 Markdown 引擎是自动添加 ID 的。标题 ID 的作用是允许其他地方通过锚点直接跳转到该标题。标题指定 ID 的语法是在标题后面通过花括号包裹 ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 这是一个标题 &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure><p>渲染结果：</p><h3 id="custom-id">这是一个标题</h3><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注释语法 不会显示在浏览器中 --&gt;</span><br><span class="line">&lt;!-- shortcuts Ctrl + &#x2F; --&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[comment]:&lt;&gt; &quot;hack方法：利用markdown的解析原理来实现注释的。 语法就是这样。。。[name]:&lt;&gt; &amp; #&quot;</span><br><span class="line">[comment]:# &quot;comments.....&quot;</span><br></pre></td></tr></table></figure><h2 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [×] Task One &#96;task content...&#96;</span><br><span class="line">- [√] Task Two &#96;task content...&#96;  </span><br></pre></td></tr></table></figure><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*斜体*  _斜体_</span><br><span class="line">**粗体**  </span><br><span class="line">***加粗斜体***  </span><br><span class="line">~~删除线~~    </span><br><span class="line">&lt;u&gt;下划线&lt;&#x2F;u&gt;   </span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块 (```)"></a>代码块 (```)</h2><figure class="highlight ruby"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;redcarpet&#x27;</span></span><br><span class="line">markdown = Redcarpet.new(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure><h2 id="MarkDown-区块"><a href="#MarkDown-区块" class="headerlink" title="MarkDown 区块"></a>MarkDown 区块</h2><!-- 嵌套区块 --><p>可嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; level 1</span><br><span class="line">&gt; &gt; level 2</span><br><span class="line">&gt; &gt; &gt; level3  </span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>level 1</p><blockquote><p>level 2</p><blockquote><p>level3  </p></blockquote></blockquote></blockquote><h2 id="链接地址"><a href="#链接地址" class="headerlink" title="链接地址_"></a>链接地址_</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;文字套链接 bilibili链接   [bilibili](bilibili.com)  </span><br><span class="line">&gt;直接使用链接&lt;bilibili.com&gt;</span><br><span class="line">&gt;高级链接 调用变量访问[哔哩哔哩][BZ]</span><br><span class="line">(这里的解释器似乎不支持)</span><br><span class="line">&gt;这是一个emoji网站 点击即可复制 🤣 [Emoji](http:&#x2F;&#x2F;emojihomepage.com&#x2F;)</span><br></pre></td></tr></table></figure><h2 id="MarkDown-pic"><a href="#MarkDown-pic" class="headerlink" title="MarkDown pic"></a>MarkDown pic</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;![zhihu.com](https:&#x2F;&#x2F;static.zhihu.com&#x2F;heifetz&#x2F;assets&#x2F;logo.f6eef033.png)  </span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用短横线 — 来分隔表头和表身，使用竖线 | 来分隔列，每行开头和结尾的竖线是可选的。</p><p>如果需要左对齐、居中对齐或者右对齐表格内容，可以通过在 <code>---</code> 中添加冒号 <code>:</code> 实现。冒号仅出现在左边表示左对齐，出现在两边表示居中对齐，仅出现在右边表示右对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Left | Middle | Right |</span><br><span class="line">| :--- | :----- | :---- |</span><br><span class="line">| 1    | 2      | 3     |</span><br></pre></td></tr></table></figure><p>渲染效果：<br>| Left | Middle | Right |<br>| :— | :—– | :—- |<br>| 1    | 2      | 3     |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">| Shortcuts            | Functionality              |</span><br><span class="line">| :------------------- | :------------------------- |</span><br><span class="line">| cmd-k v or ctrl-k v  | Open preview to the Side   |</span><br><span class="line">| cmd-shift-v or       | ctrl-shift-v    Open preview|</span><br><span class="line">| ctrl-shift-s         | Sync preview &#x2F; Sync source |</span><br><span class="line">| shift-enter          | Run Code Chunk             |</span><br><span class="line">| ctrl-shift-enter     | Run all Code Chunks        |</span><br><span class="line">| cmd-&#x3D; or cmd-shift-&#x3D; | Preview zoom in            |</span><br><span class="line">| cmd-- or cmd-shift-_ | Preview zoom out           |</span><br><span class="line">| cmd-0                | Preview reset zoom         |</span><br><span class="line">| esc                  | Toggle sidebar TOC         |</span><br></pre></td></tr></table></figure><blockquote><p><strong>Markdown Preview Enhanced Shotcuts  ☝</strong></p></blockquote><h3 id="表格内容排版"><a href="#表格内容排版" class="headerlink" title="表格内容排版"></a>表格内容排版</h3><p>表格中的内容也可以进行排版，比如加粗、强调文本，插入超链接等。但仅限于使用“行级元素”进行排版，不能使用“块级元素”，比如不能使用标题、块引用、列表、分隔线等。</p><h3 id="表格内容转义竖线"><a href="#表格内容转义竖线" class="headerlink" title="表格内容转义竖线"></a>表格内容转义竖线</h3><p>如果需要在表格内容中使用竖线 <code>|</code>，那就需要对其进行转义。可以使用 <code>\|</code> 转义，但更稳妥的做法是写竖线的 HTML 实体表示 <code>|</code>，因为有的 Markdown 引擎不能正确处理表格内容中的 <code>\|</code>。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><blockquote><p>HEXO 似乎不支持，但可以通过插件hexo-renderer-markdown-it x渲染添加脚注</p></blockquote><p>脚注用于在文末添加细节说明或者参考，这样文章的正文部分看上去会更加简洁清晰。创建脚注后，正文中引用脚注的地方会出现一个上标数字链接，读者点击后跳转到文末脚注定义的对应位置。</p><p>脚注引用通过 <code>[^标识符]</code> 创建，标识符部分可以是数字或者文本，但不能包含空格或者制表符。标识符仅用于关联引用和定义，在渲染时会自动根据脚注定义顺序进行数字递增渲染。不过这也不是绝对的，某些 Markdown 引擎也会将标识符部分用于渲染。</p><p>脚注定义使用 <code>[^标识符]:</code> 来创建，冒号后面就是需要添加的细节说明或者参考。脚注定义不一定非要放在整个 Markdown 文本的末尾，夹在段落、列表或者块引用之间也是可以工作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里是一个脚注引用[^1]，这里是另一个脚注引用[^bignote]。</span><br><span class="line"></span><br><span class="line">[^1]: 第一个脚注定义。</span><br><span class="line">[^bignote]: 脚注定义可使用多段内容。</span><br><span class="line"></span><br><span class="line">    缩进对齐的段落包含在这个脚注定义内。</span><br><span class="line">    还有其他行级排版语法，比如**加粗**和[链接](https:&#x2F;&#x2F;b3log.org)。</span><br></pre></td></tr></table></figure><p>渲染结果:<br>这里是一个脚注引用<a href="%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%84%9A%E6%B3%A8%E5%AE%9A%E4%B9%89%E3%80%82">^1</a>，这里是另一个脚注引用<a href="%E8%84%9A%E6%B3%A8%E5%AE%9A%E4%B9%89%E5%8F%AF%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%AE%B5%E5%86%85%E5%AE%B9%E3%80%82">^bignote</a>。</p><p>缩进对齐的段落包含在这个脚注定义内。<br>还有其他行级排版语法，比如<strong>加粗</strong>和<a href="https://b3log.org/">链接</a>。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文部分转载自 <a href="https://ld246.com/article/1583305480675">链滴</a> ….</p>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog搭建问题与一些话...</title>
      <link href="/2020/10/26/%E4%B8%80%E4%BA%9B%E8%AF%9D/"/>
      <url>/2020/10/26/%E4%B8%80%E4%BA%9B%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="🌳-一些话"><a href="#🌳-一些话" class="headerlink" title="🌳　一些话"></a>🌳　一些话</h2><p>今天(<font color="#1C9849">2020年4月7日</font> 完成了部分对于Blog主页的美化<br>主要是明白了github将资源提交至CDN,我也将具体的操作写在下文…本人对前端知识所知甚微。<br>所提供的仅仅只是参考。</p><h2 id="🌴-CDN-Github"><a href="#🌴-CDN-Github" class="headerlink" title="🌴　CDN  - Github"></a>🌴　CDN  - Github</h2><p>建立新的储存库<br>若从本地上传至远端，则先克隆库至本地，使用命令<font color="#0099FF"><strong>git clone</strong></font> + cloneURL<br>新建资源文件夹，将需要存储至远端的文件放入到资源文件目录，此时可以<font color="#0099FF" ><strong>git status</strong></font>查看库状态。<br><font color="#0099FF"><strong>git add</strong></font> 将文件添加到暂存(添加到索引) 使用 <font color="#0099FF" ><strong>git commit -m</strong> “”</font> 引号内填写对添加文件的描述，最后<font color="#0099FF" > <strong>git push</strong></font> 到Github远端<br>回到Github cdn库 创建<font color="#1C9849" > 发行版( release)</font> 即可在以下网址查看 👇 (个人使用jsDelivr)<br>    <a href="https://cdn.jsdelivr.net/gh/github%E7%94%A8%E6%88%B7/%E5%BA%93@%E5%8F%91%E8%A1%8C%E7%89%88%E5%8F%B7/">https://cdn.jsdelivr.net/gh/github用户/库@发行版号/</a> </p><h2 id="😆-感谢"><a href="#😆-感谢" class="headerlink" title="😆　感谢"></a>😆　感谢</h2><p>感谢访问这个blog！有什么建议可以在QQ&amp;<a href="https://github.com/FreeXMelody">Github</a>上告诉我~！ 😊 &lt;&lt;<br><br/><br><br/></p><blockquote><h2 id="📖-参考"><a href="#📖-参考" class="headerlink" title="📖　参考"></a>📖　参考</h2><p>如果生成时错误 <font color="#BB3B29" >fatal: cannot read property code of undefined</font><br>可能是 <font color="#0099FF" ><strong>package.json</strong></font> 配置出错</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCSDK建立控制器连接进行文件传输</title>
      <link href="/2020/09/10/PCSDK-link/"/>
      <url>/2020/09/10/PCSDK-link/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info"><p>项目已开源，可在<a href="https://github.com/FreeXMelody/RapidController">Github</a>查看</p></div><h2 id="PCSDK-二次开发-数据传输"><a href="#PCSDK-二次开发-数据传输" class="headerlink" title="PCSDK 二次开发 数据传输"></a>PCSDK 二次开发 数据传输</h2><p>首次使用PCSDK进行二次开发，上位机需安装PCSDK，于vs引用dll,替换App.config文件</p><h3 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用:"></a>添加引用:</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ABB.Robotics;</span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers;</span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers.Discovery;   </span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers.EventLogDomain;</span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers.FileSystemDomain;</span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers.MotionDomain;</span><br><span class="line"><span class="keyword">using</span> ABB.Robotics.Controllers.RapidDomain;</span><br></pre></td></tr></table></figure><h3 id="0-×-01-配置网线："><a href="#0-×-01-配置网线：" class="headerlink" title="0 × 01 配置网线："></a>0 × 01 配置网线：</h3><p>接入网线，上位机IP改为自动获取</p><h3 id="0-×-02-代码实现："><a href="#0-×-02-代码实现：" class="headerlink" title="0 × 02 代码实现："></a>0 × 02 代码实现：</h3><p>界面设计略过~ （并没有好康的UI -w-</p><p><strong>其余功能基于以下方法实现</strong>······</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetworkScanner scanner = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> Controller controller = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>扫描控制器：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNetwork</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> NetworkScanner();</span><br><span class="line">    scanner.Scan();</span><br><span class="line">    controllers = scanner.Controllers;</span><br><span class="line">    <span class="comment">// listBox1.Items.Clear();</span></span><br><span class="line">    ListViewItem listViewItem1;</span><br><span class="line">    listView1.Items.Clear();</span><br><span class="line">    <span class="keyword">foreach</span> (ControllerInfo info <span class="keyword">in</span> controllers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// INDEX: SysName/ IP / ControllerName / SysInfo  / ID / Port</span></span><br><span class="line">        listViewItem1 = <span class="keyword">new</span> ListViewItem(info.SystemName);</span><br><span class="line">        listViewItem1.SubItems.Add(info.IPAddress.ToString());</span><br><span class="line">        listViewItem1.SubItems.Add(info.ControllerName);</span><br><span class="line">        listViewItem1.SubItems.Add(info.Version.ToString());</span><br><span class="line">        listViewItem1.SubItems.Add(info.SystemId.ToString());</span><br><span class="line">        listViewItem1.SubItems.Add(info.WebServicesPort.ToString());</span><br><span class="line">        listView1.Items.Add(listViewItem1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接到控制器：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectController</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (ControllerInfo info <span class="keyword">in</span> controllers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (controller != <span class="literal">null</span>) <span class="comment">// 登出</span></span><br><span class="line">        &#123;</span><br><span class="line">            controller.Logoff();</span><br><span class="line">            label2_INFO.Text = <span class="string">&quot;已断开连接。&quot;</span>;</span><br><span class="line">            Text = <span class="string">&quot;已断开连接....&quot;</span>;</span><br><span class="line">            setInfoColor();</span><br><span class="line">            controller.Dispose();</span><br><span class="line">            controller = <span class="literal">null</span>;</span><br><span class="line">            button_connect.Text = <span class="string">&quot;     连接&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 登入</span></span><br><span class="line">        &#123;</span><br><span class="line">            Guid a = <span class="keyword">new</span> Guid();</span><br><span class="line">            a = Guid.Parse(listView1.SelectedItems[<span class="number">0</span>].SubItems[<span class="number">4</span>].Text);</span><br><span class="line">            controller = Controller.Connect(a, ConnectionType.Standalone);</span><br><span class="line">            controller.Logon(UserInfo.DefaultUser);</span><br><span class="line">            Text = <span class="string">&quot;当前已连接：&quot;</span> + listView1.SelectedItems[<span class="number">0</span>].Text;</span><br><span class="line">            label2_INFO.Text = <span class="string">&quot;已连接。&quot;</span>;</span><br><span class="line">            setInfoColor();</span><br><span class="line">            ShowNewMessage(<span class="string">&quot;已连接到控制器：&quot;</span> + listView1.SelectedItems[<span class="number">0</span>].Text);</span><br><span class="line">            button_connect.Text = <span class="string">&quot;     断开&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> ABB RAPID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 练习</title>
      <link href="/2020/08/19/PythonQuiz/"/>
      <url>/2020/08/19/PythonQuiz/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="基础复习"><a href="#基础复习" class="headerlink" title="基础复习"></a>基础复习</h2><blockquote><p>✒️ 此标题下将进行简单的基础概念描述与代码演示。</p></blockquote><p>元组：可以视为一个只读型的列表，<code>不允许修改数据</code><br>集合：与数学中集合概念相似 , 一个元素只能出现一次，就算写了多个 编译器也会自动删除多余的个数</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>取出两个集合都有的元素（求<strong>并集</strong>)   👇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Intersection</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">print(set1 &amp; set2) <span class="comment"># &#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>并集 Union</strong> , 求两个集合总共有哪些元素 , 不重复 使用 | 运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Union</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">print(set1 | set2)  <span class="comment"># &#123;1,2,3,4,5,6,7&#125;</span></span><br></pre></td></tr></table></figure><p><strong>差集 Difference</strong>  求set1和set2的差集，将返回在set1中但不在set2中的元素（左操作数）。 使用 - 运算符实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Union</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">print(set1 - set2)  <span class="comment"># &#123;4,5&#125;</span></span><br></pre></td></tr></table></figure><p><strong>对称差集 Symmetric Difference</strong> ， 求set1和set2的对称差集时，将返回不同时存在set1和set2中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">print(set1 ^ set2)  <span class="comment"># &#123;4,5,6,7&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Enumerate-函数"><a href="#Enumerate-函数" class="headerlink" title="Enumerate() 函数"></a>Enumerate() 函数</h3><div style="border: olivedrab solid 1px; border-radius:2px; width: 100%; display: inline-block; padding-bottom: 3px; padding-left: 6px;"><i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">&#xe683;   </i><span style="color: olivedrab; font-size: 15px; font-family: Georgia, serif; margin-right: 4px; ">Refer</span><a href="https://www.runoob.com/python/python-func-enumerate.html" style="background-color: #8BBA2E; color: #EDEDED; padding:5px 10px; font-size: 14px;">RUNOOB</a><span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif; font-size:10px; ">"enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。"</span></div><h3 id="类，Python中的OOP"><a href="#类，Python中的OOP" class="headerlink" title="类，Python中的OOP"></a>类，Python中的OOP</h3><p><code>__init__</code> 函数 ， 用于初始化一些类字段，但第一个参数必须是<code>self</code> ，这是规定<br>self 实际就是指实例对象本身，类中定义方法的时候，内部访问self参数也必须将self参数写到第一个参数位置</p><h2 id="Python-阿姆斯特朗数-水仙花数-提高题"><a href="#Python-阿姆斯特朗数-水仙花数-提高题" class="headerlink" title="Python 阿姆斯特朗数 (水仙花数) 提高题"></a>Python 阿姆斯特朗数 (水仙花数) 提高题</h2><p>阿姆斯特朗数：一个n位的正整数等于各位数字n次幂的和，则该数就为阿姆斯特朗数。</p><p>例如1^3 + 5^3 + 3^3 = 153 则153为阿姆斯特朗数。</p><p>写一个程序，检测输入数字是否为阿姆斯特朗数。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># math.pow(x,y) 求x的y次幂</span></span><br><span class="line">num= input(<span class="string">&quot;输入一个数····&quot;</span>)</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">index =[]</span><br><span class="line">rec = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str(num):  <span class="comment"># 取到各个数位上的数字并加入index列表</span></span><br><span class="line">    index.append(int(i))</span><br><span class="line">  <span class="comment">#  print(index)</span></span><br><span class="line">  <span class="comment"># 获取列表长度</span></span><br><span class="line">length = len(index)</span><br><span class="line"><span class="keyword">for</span> a  <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">     rec.append(int(math.pow(index[a],length)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length):</span><br><span class="line">     g_num  += rec[i]</span><br><span class="line">print(<span class="string">&quot;结果为%d&quot;</span>%g_num)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> g_num == int(num):</span><br><span class="line">    print(<span class="string">&quot;这是一个阿姆斯特朗数·· &quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;输入的数值非阿姆斯特朗数.....&quot;</span>)</span><br></pre></td></tr></table></figure><p>接下来看看百科上给出的例子供参考：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">narcissistic_number_1</span>(<span class="params">num</span>):</span></span><br><span class="line">    length = len(str(num))</span><br><span class="line">    count = length</span><br><span class="line">    num_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count:</span><br><span class="line">        num_sum += ((num // <span class="number">10</span> ** (count - <span class="number">1</span>)) % <span class="number">10</span>) ** length <span class="comment"># 注意运算符的优先级</span></span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num_sum == num:</span><br><span class="line">        print(<span class="string">&quot;%d is %d bit narcissistic_number&quot;</span> % (num, length))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;is not a narcissistic number&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">narcissistic_number_2</span>(<span class="params">num</span>):</span></span><br><span class="line">    s = str(num)</span><br><span class="line">    length = len(s)</span><br><span class="line">    sum_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        sum_num += int(i)**length</span><br><span class="line">    <span class="keyword">if</span> sum_num == num:</span><br><span class="line">        print(<span class="string">&quot;%d is a %d bit narcissistic_number&quot;</span> % (num, length)</span><br><span class="line">              </span><br><span class="line">max_num = int(input(<span class="string">&#x27;请输入最大范围&#x27;</span>))</span><br><span class="line"><span class="comment"># 获取小于指定数的阿姆斯特朗数</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>, max_num):</span><br><span class="line">    narcissistic_number_1(num)        <span class="comment">#调用方法一,方法二均可</span></span><br></pre></td></tr></table></figure><h2 id="一些进阶小技巧"><a href="#一些进阶小技巧" class="headerlink" title="一些进阶小技巧"></a>一些进阶小技巧</h2><h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><p>列表的切片赋值操作可以当作插入元素来使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 [3,4,5,6,&#x27;Hello&#x27;] 列表插入到 2，3之间</span></span><br><span class="line">i = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">i[<span class="number">2</span>:<span class="number">2</span>] = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&#x27;Hello&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端因Live2d造成的访问卡顿解决方案</title>
      <link href="/2020/08/15/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%A0Live2d%E9%80%A0%E6%88%90%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/08/15/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%A0Live2d%E9%80%A0%E6%88%90%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实现Live2d应用到Hexo博客后，通过移动端对网页的访问，发现Live2d并不在移动端显示，但网页载入速度堪忧，滑动屏幕有明显卡顿 经过搜索查询后，得知看板娘虽然不显示，但是其<code>JS</code>和<code>CSS</code>文件仍会加载，占用大量资源而造成的问题。</br><br>主要参考：<a href="https://cangshui.net/3518.html">https://cangshui.net/3518.html</a></br><br>感谢原作者的分享。</p><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><p>将之前所配置的<code>Inject</code>项清除。</p><p>与自己的live2d目录JS文件夹下新建一个JS文件(文件名自定)</p><p>写入JS文件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">browserRedirect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sUserAgent = navigator.userAgent.toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> bIsIpad = sUserAgent.match(<span class="regexp">/ipad/i</span>) == <span class="string">&quot;ipad&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsIphoneOs = sUserAgent.match(<span class="regexp">/iphone os/i</span>) == <span class="string">&quot;iphone os&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsMidp = sUserAgent.match(<span class="regexp">/midp/i</span>) == <span class="string">&quot;midp&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsUc7 = sUserAgent.match(<span class="regexp">/rv:1.2.3.4/i</span>) == <span class="string">&quot;rv:1.2.3.4&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsUc = sUserAgent.match(<span class="regexp">/ucweb/i</span>) == <span class="string">&quot;ucweb&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsAndroid = sUserAgent.match(<span class="regexp">/android/i</span>) == <span class="string">&quot;android&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsCE = sUserAgent.match(<span class="regexp">/windows ce/i</span>) == <span class="string">&quot;windows ce&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> bIsWM = sUserAgent.match(<span class="regexp">/windows mobile/i</span>) == <span class="string">&quot;windows mobile&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;/live2d/live2d/css/live2d.css&quot; /&gt;&lt;div id=&quot;landlord&quot;&gt; &lt;div class=&quot;message&quot; style=&quot;opacity:0.5&quot;&gt;&lt;/div&gt; &lt;canvas id=&quot;live2d&quot; width=&quot;280&quot; height=&quot;250&quot; class=&quot;live2d&quot;&gt;&lt;/canvas&gt; &lt;div class=&quot;hide-button&quot;&gt;&lt;font color=&quot;#FFFFFF&quot;&gt;隐藏&lt;/font&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot;&gt; var message_Path = &quot;/live2d/live2d/&quot;&lt;/script&gt;&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot;&gt; var home_Path = &quot;https://fxlabtinystar.cn/&quot; &lt;/script&gt;&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/live2d/live2d/js/live2d.js&quot;&gt;&lt;/script&gt;&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/live2d/live2d/js/message.js&quot;&gt;&lt;/script&gt;&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot;&gt; loadlive2d(&quot;live2d&quot;, &quot;/live2d/live2d/model/XueXiaoban/XueXiaoban.model.json&quot;);&lt;/script&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">browserRedirect();</span><br></pre></td></tr></table></figure><p>注意路径正确····改成自己的</p><p>然后在<code>Inject.Bottom</code>项中引用此JS即可完成配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">&#x27;&lt;script data-pjax src=&quot;/live2d/live2d/js/index.js&quot;&gt;&lt;/script&gt;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Live2d </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2d应用到Hexo 看板娘</title>
      <link href="/2020/08/14/Live2dAndHexo/"/>
      <url>/2020/08/14/Live2dAndHexo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note default"><p>Live2d配置搭建已更新，详细查看<a href="https://fxlabtinystar.cn/2020/08/15/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%A0Live2d%E9%80%A0%E6%88%90%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">移动端因Live2d造成的访问卡顿解决方案</a></p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  前俩天在逛Blog的时候看到了一只超可爱的看板娘，直接心动…遂往自己的blog中加入了经轻微改动的血小板！<br>  以下提供2中不同的方法…可自行选择！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>插件安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>模型安装：</br><br>模型的选择可以是自己制作的或是网上下载的，<a href="https://github.com/xiazeyu/live2d-widget-models">这里</a>提供了作者的模型…</br><br>详细配置设置可以在Github项目查看 <a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">&gt;传送&lt;</a></p><h2 id="第二选择"><a href="#第二选择" class="headerlink" title="第二选择"></a>第二选择</h2><p>// 如果只需要显示看板娘而不需要其他的功能的话…使用以上方法就够了.<br></br><br>啊当然…如果需要一些功能，比如打招呼…对一些行为事件作出反应，就需要用到其他方法…<br></br></p><blockquote><p>这个方法不需要安装 hexo-helper-live2d …</br><br>以下我将通过操作复述作者原话( emmmm….实际参考dalao的Github就可以完成…</br></p></blockquote><h3 id="0-×-01-准备"><a href="#0-×-01-准备" class="headerlink" title="0 × 01 准备"></a>0 × 01 准备</h3><p>先到dalao的<a href="https://github.com/galnetwen/Live2D">Github</a>下载整理后的Live2d代码，解压到</br></p><blockquote><p>\themes\’主题‘\source </p></blockquote></br>目录下,重命名文件夹为Live2d<h3 id="0-×-02-修改配置"><a href="#0-×-02-修改配置" class="headerlink" title="0 × 02 修改配置"></a>0 × 02 修改配置</h3><p>我们不修改主题文件，所以在主题配置文件中外挂样式、脚本</br><br>inject配置项 bottom 中插入代码并确认路径正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;live2d.css路径 如：&#x2F;live2d&#x2F;css&#x2F;live2d.css&quot; &#x2F;&gt;&lt;div id&#x3D;&quot;landlord&quot;&gt; &lt;div class&#x3D;&quot;message&quot; style&#x3D;&quot;opacity:0&quot;&gt;&lt;&#x2F;div&gt; &lt;canvas id&#x3D;&quot;live2d&quot; width&#x3D;&quot;280&quot; height&#x3D;&quot;250&quot; class&#x3D;&quot;live2d&quot;&gt;&lt;&#x2F;canvas&gt; &lt;div class&#x3D;&quot;hide-button&quot;&gt;&lt;font color&#x3D;&quot;#FFFFFF&quot;&gt;隐藏&lt;&#x2F;font&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>接下来引入脚本并确认路径：</br><br>message 路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var message_Path &#x3D; &#39;&#x2F;live2d&#x2F;live2d&#39;&lt;&#x2F;script&gt; </span><br></pre></td></tr></table></figure><p>主页配置 此处修改为你的域名，必须带斜杠</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var home_Path &#x3D; &#39;你的blog&#x2F;&#39; &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>live2d.js路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;live2d&#x2F;live2d&#x2F;js&#x2F;live2d.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>message.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;live2d&#x2F;live2d&#x2F;js&#x2F;message.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>模型json路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; loadlive2d(&quot;live2d&quot;, &quot;&#x2F;live2d&#x2F;live2d&#x2F;model&#x2F;XueXiaoban&#x2F;XueXiaoban.model.json&quot;); &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>至此，就搭建好看板娘啦…至于模型动作 事件回应需要另外手动配置…</p></blockquote><p>于模型.json中配置看板娘的动作···<br>message.json中配置事件回应···<br>js中拓展你所需要的功能…( 对应节日的提醒什么的<br></br><br>什么！你想让看板娘有玩游戏，换装的功能？<br>可以使用 <a href="https://github.com/stevenjoezhang/live2d-widget">live2d-widget</a> , 要使用非官方模型需要搭建后台API····我还太菜:(</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterflyTest 🔎</title>
      <link href="/2020/08/10/ButterflyTest/"/>
      <url>/2020/08/10/ButterflyTest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><li>这些可以用在MarkDown中···· ，所以评论的时候也可以应用喔！😉</li></blockquote><h2 id="Note-标注-提示块标签"><a href="#Note-标注-提示块标签" class="headerlink" title="Note 标注 提示块标签"></a>Note 标注 提示块标签</h2><div class="note default"><p>default 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note primary no-icon"><p>primary 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note success"><p>success 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note info"><p>info 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note warning"><p>warning 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note danger"><p>danger 提示块标签</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><h2 id="tag-hide"><a href="#tag-hide" class="headerlink" title="tag-hide"></a>tag-hide</h2><span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: bg;color: color">display  </button><span class="hide-content">content</span></span><p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p><p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button button--animated" style="">Click  </button><span class="hide-content">闪</span></span></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line"> 门里站着一个人? &#123;% hideInline 闪 %&#125;</span><br></pre></td></tr></table></figure><div class="hide-toggle" style="border: 1px solid #FF7242"><div class="hide-button toggle-title" style="background-color: #FF7242;color: #fff"><i class="fas fa-caret-right fa-fw"></i><span>点击查看</span></div>    <div class="hide-content"><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle 点击查看,#FF7242,#fff %&#125;</span><br><span class="line">如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><div class="hide-toggle" style="border: 1px solid bg"><div class="hide-button toggle-title" style="background-color: bg;color: color"><i class="fas fa-caret-right fa-fw"></i><span>display</span></div>    <div class="hide-content"><p>content</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>点击查看说明</span></div>    <div class="hide-content"><p>此部分默认不展开，可以是代码块</p></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% hideToggle 点击查看说明 %&#125;</span><br><span class="line">此部分默认不展开，可以是代码块</span><br><span class="line"></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="note success"><p>这真是太Cool了 </p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
