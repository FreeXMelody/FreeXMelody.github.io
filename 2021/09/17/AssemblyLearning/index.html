<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ASM PROJECT | 星 愿 🍃</title><meta name="description" content="汇编基础"><meta name="keywords" content="汇编"><meta name="author" content="Ha1Cy0nMeowo"><meta name="copyright" content="Ha1Cy0nMeowo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://fxlabtinystar.cn/2021/09/17/AssemblyLearning/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta property="og:type" content="article"><meta property="og:title" content="ASM PROJECT"><meta property="og:url" content="http://fxlabtinystar.cn/2021/09/17/AssemblyLearning/"><meta property="og:site_name" content="星 愿 🍃"><meta property="og:description" content="汇编基础"><meta property="og:image" content="https://i.loli.net/2021/09/17/CfiyHp6RdIWcTJa.png"><meta property="article:published_time" content="2021-09-17T00:24:55.000Z"><meta property="article:modified_time" content="2022-06-19T10:59:23.016Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/manifest.json"/><meta name="theme-color" content="#4dacde"/><meta name="msapplication-TileColor" content="#4dacde"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"/><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="/css/webmo.woff2"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章从发布到现在已经","messageNext":"天啦, 内容可能已经过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  last_push_date: {"zeroDay":"今天","suffix":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-06-19 18:59:23'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2247600_6euf23e4r65.css"><link rel="stylesheet" href="/css/FxCss.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome-animation@1.1.1/css/font-awesome-animation.min.css"><link rel="stylesheet" href="path/to/font-awesome/css/font-awesome.min.css"><style type="text/css">#toggle-sidebar {left:100px}</style><link rel="stylesheet" href="/css/Blogfont.css"><link rel="stylesheet" href="/css/fontStyle.css"><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/editor.md@1.5.0/css/editormd.min.css" /><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/editor.md@1.5.0/editormd.min.js"></script><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://q2.qlogo.cn/headimg_dl?dst_uin=3047124773&amp;spec=100" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-laptop-house"></i><span> 小屋😋</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-site"></i><span> 镜像站🌐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://tinystarovo.gitee.io"><i class="fa-fw iconfont icon-gitee-fill-round"></i><span> Gitee</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://freexmelody.github.io/"><i class="fa-fw iconfont icon-github"></i><span> Github</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 实验室🚀</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mdEditorInBlog/"><i class="fa-fw fas fa-file-alt"></i><span> 写作</span></a></li><li><a class="site-page" href="/QQexpPage/"><i class="fa-fw iconfont icon-expression"></i><span> QQ下架表情下载</span></a></li><li><a class="site-page" href="/dotNetFramework/"><i class="fa-fw iconfont icon-dot-net"></i><span> .Net Fiddle</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-bookmark"></i><span> 我的</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Talk/"><i class="fa-fw fas fa-comment"></i><span> 诉语</span></a></li><li><a class="site-page" href="/Photograph/"><i class="fa-fw iconfont icon-photography-creativi"></i><span> 相册</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 碎碎语⭐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-gamepad"></i><span> 轻松一刻</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/CatchTheCat/"><i class="fa-fw fas fa-cat"></i><span> 圈小猫</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐小站</span></a></li><li><a class="site-page" href="/mineSweeper/"><i class="fa-fw iconfont icon-mineset"></i><span> 扫雷</span></a></li></ul></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Part"><span class="toc-number">1.</span> <span class="toc-text">Basic Part</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Segmentation-in-8086-Microprocessor"><span class="toc-number">1.1.</span> <span class="toc-text">Memory Segmentation in 8086 Microprocessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8-%E3%80%81%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">1.2.</span> <span class="toc-text">存储器 、存储单元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%AF%B9%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.3.</span> <span class="toc-text">CPU对存储器的读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.4.</span> <span class="toc-text">内存地址空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9A%A9-%E5%AD%97%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">🚩 字在寄存器中的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%8E8086CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">几条汇编指令与8086CPU给出物理地址的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%93-%E6%B5%8B%E9%AA%8C%E9%A2%98%E8%A7%A3-2-2"><span class="toc-number">2.3.</span> <span class="toc-text">🔓 测验题解 - 2.2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-IP-CS-%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">2.5.</span> <span class="toc-text">关于 IP &#x2F; CS 的修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-number">3.</span> <span class="toc-text">寄存器与内存访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9A%A9-CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">🚩 CPU提供的栈机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop-push-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">pop &#x2F; push 的执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%BB%BC%E8%BF%B0"><span class="toc-number">3.3.</span> <span class="toc-text">栈综述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%85%B3%E4%BA%8E32%E4%BD%8D%E6%9E%B6%E6%9E%84%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BB%A5%E5%86%85%E5%AD%98%E5%88%B0%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.</span> <span class="toc-text">⭐ 关于32位架构中为什么不能以内存到内存的形式传递数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%AA%8C%E4%B8%89-%E7%BC%96%E7%A8%8B-%E7%BC%96%E8%AF%91-%E8%BF%9E%E6%8E%A5-%E8%B7%9F%E8%B8%AA-%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">📌 实验三 - 编程|编译|连接|跟踪     - - 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base-Register-bx-And-Loop-instruction"><span class="toc-number">5.</span> <span class="toc-text">Base Register[bx] And Loop instruction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Debug%E5%92%8C%E6%B1%87%E7%BC%96%E7%BC%96%E8%AF%91%E5%99%A8MASM%E5%AF%B9%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">Debug和汇编编译器MASM对指令的不同处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Concept-%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-number">5.2.</span> <span class="toc-text">(Concept)段前缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%AA%8C%E5%9B%9B-bx-%E4%B8%8ELoop%E7%9A%84%E4%BD%BF%E7%94%A8-3-%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">📌 实验四 - [bx]与Loop的使用 (3)     - - 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8D%8A-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-6-3"><span class="toc-number">7.1.</span> <span class="toc-text">🍊 程序分析 6.3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">编写多段程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%AA%8C%E4%BA%94-%E7%BC%96%E5%86%99%E4%B8%8E%E8%B0%83%E8%AF%95%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F-%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">📌 实验五 - 编写与调试多段程序     - - 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Experiment-5-Quiz-1"><span class="toc-number">8.1.</span> <span class="toc-text">Experiment 5 Quiz 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Experiment-5-Quiz-5"><span class="toc-number">8.2.</span> <span class="toc-text">Experiment 5 Quiz 5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Experiment-5-Quiz-6"><span class="toc-number">8.3.</span> <span class="toc-text">Experiment 5 Quiz 6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AND-%E4%B8%8E-OR-%E6%8C%87%E4%BB%A4"><span class="toc-number">9.1.</span> <span class="toc-text">AND 与 OR 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">9.2.</span> <span class="toc-text">以字符形式给出的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BX-IDATA"><span class="toc-number">9.3.</span> <span class="toc-text">[ BX + IDATA ]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SI-Source-Index-Register-amp-DI-Destination-Index-Register"><span class="toc-number">9.4.</span> <span class="toc-text">SI (Source Index Register) &amp; DI (Destination Index Register)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">不同寻址方式的灵活应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9A%82%E5%AD%98"><span class="toc-number">9.6.</span> <span class="toc-text">关于数据的暂存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%AA%8C%E5%85%AD-%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%B9%B6%E4%BF%AE%E6%94%B9%E5%80%BC-%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text">📌 实验六 - 灵活定位内存地址并修改值     - - 分析调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8E%E6%B1%87%E7%BC%96%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">11.1.</span> <span class="toc-text">于汇编中数据位置的表达</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%98%8E%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6-x-ptr"><span class="toc-number">11.2.</span> <span class="toc-text">指明要处理的数据长度 - x ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#div-Instruction"><span class="toc-number">11.3.</span> <span class="toc-text">div Instruction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup-Operator"><span class="toc-number">11.4.</span> <span class="toc-text">dup Operator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9E%E9%AA%8C%E4%B8%83-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%9C%A8%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">📌 实验七 - 寻址方式在结构化数据访问中的应用     - - 分析调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">转移指令及其原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-Offset"><span class="toc-number">13.1.</span> <span class="toc-text">操作符 Offset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jmp-%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.</span> <span class="toc-text">Jmp 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84-JMP-%E6%8C%87%E4%BB%A4-%E8%A1%A5%E7%A0%81"><span class="toc-number">13.2.1.</span> <span class="toc-text">依据位移进行转移的 JMP 指令 +. 补码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.2.</span> <span class="toc-text">转移地址在寄存器中的jmp指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">13.2.3.</span> <span class="toc-text">🛠️转移地址在内存中的jmp指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jcxz%E6%8C%87%E4%BB%A4-Jump-if-CX-equals-Zero"><span class="toc-number">13.2.4.</span> <span class="toc-text">jcxz指令 (Jump if CX equals Zero)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-%E6%8C%87%E4%BB%A4"><span class="toc-number">13.3.</span> <span class="toc-text">loop 指令</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/09/17/CfiyHp6RdIWcTJa.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">星 愿 🍃</a></span><span class="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-laptop-house"></i><span> 小屋😋</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-site"></i><span> 镜像站🌐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://tinystarovo.gitee.io"><i class="fa-fw iconfont icon-gitee-fill-round"></i><span> Gitee</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://freexmelody.github.io/"><i class="fa-fw iconfont icon-github"></i><span> Github</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-history"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 实验室🚀</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/mdEditorInBlog/"><i class="fa-fw fas fa-file-alt"></i><span> 写作</span></a></li><li><a class="site-page" href="/QQexpPage/"><i class="fa-fw iconfont icon-expression"></i><span> QQ下架表情下载</span></a></li><li><a class="site-page" href="/dotNetFramework/"><i class="fa-fw iconfont icon-dot-net"></i><span> .Net Fiddle</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-bookmark"></i><span> 我的</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Talk/"><i class="fa-fw fas fa-comment"></i><span> 诉语</span></a></li><li><a class="site-page" href="/Photograph/"><i class="fa-fw iconfont icon-photography-creativi"></i><span> 相册</span></a></li><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li><li><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 碎碎语⭐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-gamepad"></i><span> 轻松一刻</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/CatchTheCat/"><i class="fa-fw fas fa-cat"></i><span> 圈小猫</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐小站</span></a></li><li><a class="site-page" href="/mineSweeper/"><i class="fa-fw iconfont icon-mineset"></i><span> 扫雷</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">ASM PROJECT</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-17T00:24:55.000Z" title="发表于 2021-09-17 08:24:55">2021-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-19T10:59:23.016Z" title="更新于 2022-06-19 18:59:23">2022-06-19</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/09/17/AssemblyLearning/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/09/17/AssemblyLearning/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><!-- 强行适配.. -->
<div style="height:385px; width:100%; overflow:hidden; position:relative; top:-30px;" >
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/17/CfiyHp6RdIWcTJa.png" width=700;>
</div>

<div style="float:left; margin-left:22%;"><img src= "/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Based%20on-Assembly_Edition_4-blue?&style=for-the-badge" ></div>
<div style="float:left; margin-left:10px;"><img src= "/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Based%20on-Interest_&_Love-green?&style=for-the-badge"></div>

<hr>
<h3 id="Basic-Part"><a href="#Basic-Part" class="headerlink" title="Basic Part"></a>Basic Part</h3><h4 id="Memory-Segmentation-in-8086-Microprocessor"><a href="#Memory-Segmentation-in-8086-Microprocessor" class="headerlink" title="Memory Segmentation in 8086 Microprocessor"></a>Memory Segmentation in 8086 Microprocessor</h4><p>REF ….</p>
<h4 id="存储器-、存储单元"><a href="#存储器-、存储单元" class="headerlink" title="存储器 、存储单元"></a>存储器 、存储单元</h4><p><code>存储器</code> 也就是我们平时所说的<code>内存</code> 。 负责为CPU提供指令和数据 , 在一台PC机中内存的作用仅次于CPU,存储器被划分为若干个<code>存储单元</code>, 每个存储单元从0开始顺序编号. 一般微型机的存储器的存储单元可以存储一个<code>Byte</code>,即一个字节(8个二进制位) - <code>微机存储器容量的最小单位</code>。</p>
<p>一般应具有 存储数据 和 读写数据 的功能， 每个单元有一个地址，是一个整数 编码 ，可以表示为 二进制 整数。</p>
<p>磁盘不同于内存,磁盘上的数据或程序不读取到内存中就无法被CPU使用</p>
<h4 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h4><p>存储单元在存储器中顺序编号，这些编号可以看作存储单元在存储器中的地址。</p>
<p>计算机中 连接 CPU 与其他芯片的导线被称作是 <code>&quot;总线&quot;</code> ,<br>根据传输信息的不同， 其从逻辑上可分为三类 : </p>
<ul>
<li><p>地址总线 (CPU通过地址总线来指定存储器单元)</p>
<p>地址总线的宽度<code>(位数)决定了CPU寻址的最大空间大小,假设一个CPU有10根地址总线,其寻址最大数为2^10 = 1024个</code>  最小数为0,最大数为1023</p>
<p>地址总线可寻到的内存单元构成了这个CPU的<code>内存地址空间</code>。</p>
</li>
<li><p>控制总线</p>
<p>控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<p>CPU通过地址总线来指定存储单元 ，控制总线上能传送信息的多少（控制总线的宽度），决定了CPU可以对多少个存储单元进行寻址。</p>
</li>
<li><p>数据总线</p>
<p>数据总线的宽度决定了<code>CPU与外界的数据传输速度</code> , 8根数据总线可以一次传送8位二进制数据 (即1Byte),</p>
<p>后注: 8086CPU数据总线宽度为16 ,寄存器为16位, 即一次最大可传送<code>一个字</code>的数据大小</p>
<p>计算机的<code>字长</code>即取决于数据总线的宽度.</p>
</li>
</ul>
<h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><p>CPU操作存储器(RAM ROM 带有BIOS的ROM)时将他们看作内存来对待,将他们总的看作一个<code>由若干个存储单元组成的逻辑存储器</code>. 这个逻辑存储器就是所说的内存空间地址.</p>
<p>每一个物理存储器在这个逻辑存储器中占有一个地址段,即一段<code>地址空间</code>,对于CPU来说,在这段地址空间中进行数据读写 , 实际也就是对对应的物理存储器进行读写.</p>
<p>因为内存空间地址与存储单元相关,其大小受到CPU地址总线宽度的限制,例如8086CPU的地址总线为<code>20</code>,则其可以传送<code>2^20</code>个不同的地址信息<code>(0 ~ 2^20-1)</code>,也就是可以定位<code>2^20</code>个内存单元,则其内存地址空间大小为 <code>2^20 / 1024^2</code></p>
<p>在基于一个计算机硬件进行系统编程时,必须知道这个系统中内存地址的分配情况, 在对某类存储器进行数据读写时,必须知道它的第一个单元的地址和最后一个单元的地址,才能保证读写操作是在预期的存储器中进行的.</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU由运算器 \ 寄存器 \ 控制器 等器件组成,这些器件靠内部的总线相连..</p>
<p>内部总线实现CPU内部各个器件之间的联系外部总线实现CPU和主板上其他器件的联系</p>
<h4 id="🚩-字在寄存器中的存储"><a href="#🚩-字在寄存器中的存储" class="headerlink" title="🚩 字在寄存器中的存储"></a>🚩 字在寄存器中的存储</h4><p>字(记为<code>word</code>) , 一个字由<code>2个字节</code>组成 这两个字节分别称为这个字的<code>高位字节</code>和<code>低位字节</code>.</p>
<p><code>字单元</code>,即存放一个字型数据(16位)的内存单元,由两个地址连续的内存单元组成, <code>高地址内存单元</code>中存放字型数据的<code>高位字节</code> , <code>低地址内存单元</code>中存放字型数据的<code>低位字节</code>.</p>
<p>由此可见8086CPU采取了<code>小端模式 </code></p>
<blockquote>
<p>所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致.  记忆: 地址的增长顺序与值的增长顺序相同</p>
</blockquote>
<p>一个十六进制数 = 四位二进制数</p>
<h4 id="几条汇编指令与8086CPU给出物理地址的方式"><a href="#几条汇编指令与8086CPU给出物理地址的方式" class="headerlink" title="几条汇编指令与8086CPU给出物理地址的方式"></a>几条汇编指令与8086CPU给出物理地址的方式</h4><p>在进行数据传送或运算时,要注意两个操作对象的位数应当是一致的. 高低位对应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">add al.bl</span><br><span class="line">add ah,bh</span><br></pre></td></tr></table></figure>

<p><code>8086CPU</code>有20位地址总线,可以传送20位地址,寻址能力<code> 2^20 (bytes) / 1024^2 (bytes) = 1MB</code></p>
<p>内部采用2个16位地址合成的方法来形成一个20位的物理地址(一个称为<code>段地址 </code>, 一个称为<code>偏移地址</code>)</p>
<p>段地址和偏移地址通过内部总线被送入一个称作<code>地址加法器</code>的部件中,<code>由它将两个16位的地址组合为20位的物理地址</code></p>
<p>地址加法器通过<code>物理地址 = 段地址 × 16(d) + 偏移地址</code>的方式合成物理地址<code>(5位十六进制数 , 即20位二进制数)</code></p>
<hr>
<p><code>段地址 × 16</code> 常用说法 <code>左移4位</code>(指二进制位) , 相当于 乘 2^4</p>
<p>关于8086CPU的物理地址的五位十六进制数表示方式:</p>
<p>因为其寻址能力为1MB , 一位十六进制数相当于4位二进制数 , 所以五位十六进制数 = 4*5 = 20位 = 2^20 = 1MB 正好符合了8086CPU的寻址能力范围.    </p>
<h4 id="🔓-测验题解-2-2"><a href="#🔓-测验题解-2-2" class="headerlink" title="🔓 测验题解 - 2.2"></a>🔓 测验题解 - 2.2</h4><p>有意思的题目…</p>
<blockquote>
<p>有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为 ? 最大为 ?</p>
</blockquote>
<p>最大值: 比较好求, 设SA为x, 则 EA为 <code>0000H</code>, x = 20000H / 16 = 2000H</p>
<p>最小值: EA 最大 为<code>FFFF</code>, 则段地址为 2 0000H - FFFF 后右移4位(逆向) 结果 1000H,但是经过验算结果非20000H 而是 <code>1FFFF</code>,初见这我也觉得很奇怪… (我的计算器绝对没有问题.jpg) 但其实<code>1FFFF即段地址1000H的最大寻址范围</code> , 与所需求内存单元就差 1 , 所以1000H + 1 = <code>1001H</code> 这才是正确的值.<code>也即是最小满足SA条件的值</code></p>
<hr>
<div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;">
<i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">
&#xe683;   
</i>
<span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/frost_soda/article/details/78450545" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">CSDN</a>
<span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Assembly Quiz 2.2"
</span>
</div>


<p>好怪但雀氏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(20000H-ffffH)&#x2F;16</span><br><span class="line">&#x3D;(10001)&#x2F;16</span><br><span class="line">这里如果不按传统算数先算括号里，而是把括号打开再算。结果就对了</span><br><span class="line">20000H &#x2F; 16 - FFFFH &#x2F; 16</span><br><span class="line">2000H - 0FFFH &#x3D; 1001H</span><br></pre></td></tr></table></figure>

<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>8086CPU有四个段寄存器 : CS \ DS \ SS \ ES</p>
<p>CS:IP 是8086CPU中最关键的俩个寄存器 , 它们指示了 CPU 当前要读取指令的地址</p>
<p>CS为<code>代码段寄存器 (Code Section)</code>  IP为指令<code>指针寄存器 (Instruction Pointer)</code></p>
<p><code>CS * 16 + IP = 物理地址</code></p>
<h4 id="关于-IP-CS-的修改"><a href="#关于-IP-CS-的修改" class="headerlink" title="关于 IP / CS 的修改"></a>关于 IP / CS 的修改</h4><p>能改变IP / CS 内容的指令被统称为<code>转移指令</code>, 目前可以用一个简单的指令来修改它们 :<code>jmp 指令</code></p>
<p>指令形如 <code>jmp 段地址:偏移地址</code>, 将CS修改为段地址, IP修改为偏移地址</p>
<p>或者使用 <code>jmp 合法寄存器</code>来修改<code>IP</code>的内容</p>
<p>e.g.  <code>jmp ax =&gt; mov IP,ax</code>  jmp指令的功能类似于这样子</p>
<h3 id="寄存器与内存访问"><a href="#寄存器与内存访问" class="headerlink" title="寄存器与内存访问"></a>寄存器与内存访问</h3><p><code>DS寄存器(数据段寄存器 ,  data segment register)</code>通常用来存储要访问数据的<code>段地址</code></p>
<h4 id="🚩-CPU提供的栈机制"><a href="#🚩-CPU提供的栈机制" class="headerlink" title="🚩 CPU提供的栈机制"></a>🚩 CPU提供的栈机制</h4><p>栈 – 拥有特殊访问方式的存储空间 –  <code>LIFO 后进先出</code>, CPU提供的最基本两个指令是 <code>PUSH(入栈) 和 POP(出栈)</code>,它们的操作都是以<code>字</code>为单位进行的</p>
<p>SS \ SP 寄存器 – <code>( Stack Segement ) / ( Stack Pointer )</code>,通过两者定义栈段,<code>任意时刻 SS:SP都指向栈顶元素</code>,CPU将从此处取得<code>栈顶</code>的地址  , 注意 CPU 只记录栈顶,栈空间的大小需要自己管理</p>
<h4 id="pop-push-的执行过程"><a href="#pop-push-的执行过程" class="headerlink" title="pop / push 的执行过程"></a>pop / push 的执行过程</h4><blockquote>
<p>执行push时.CPU的两步操作是: 先改变SP, 后向SS:SP处传送, 执行 pop时, CPU的两步操作是:先读取SS:SP处的数据,后改变SP</p>
</blockquote>
<h4 id="栈综述"><a href="#栈综述" class="headerlink" title="栈综述"></a>栈综述</h4><p>将一段内存当作栈段, 这是我们自己在编程中的安排, 想要pop / push 等栈操作指令访问我们定义的栈段,就得将<code>SS:SP</code>指向我们定义的栈段</p>
<p>一个栈段的最大容量为<code>64KB</code></p>
<p>栈满时继续压栈将导致<code>栈顶环绕</code></p>
<div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;">
<i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">
&#xe683;   
</i>
<span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_49284980/article/details/122144553" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">CSDN</a>
<span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"ASM 栈顶环绕"
</span>
</div>

<p>务必注意, 当栈空时, SS:SP将指向<code>栈底的后一个内存单元</code>.</p>
<blockquote>
<p><strong>When the stack is empty ,SP Point to the address of the next memory unit at the bottom of the stack , namely SP = At the bottom of the stack +1.</strong></p>
</blockquote>
<h4 id="⭐-关于32位架构中为什么不能以内存到内存的形式传递数据"><a href="#⭐-关于32位架构中为什么不能以内存到内存的形式传递数据" class="headerlink" title="⭐ 关于32位架构中为什么不能以内存到内存的形式传递数据"></a>⭐ 关于32位架构中为什么不能以内存到内存的形式传递数据</h4><blockquote>
<p>The answer involves a fuller understanding of RAM. Simply stated, RAM can only be in two states, read mode or write mode. If you wish to copy one byte in ram to another location, you <em>must</em> have a temporary storage area outside of RAM as you switch from read to write.</p>
<p>It is certainly possible for the architecture to have such a RAM to RAM instruction, but it would be a high level instruction that in microcode would translate to copying of data from RAM to a register then back to RAM. Alternatively, it could be possible to extend the RAM controller to have such a temporary register <em>just</em> for this copying of data, but it wouldnt provide much of a benefit for the added complexity of CPU/Hardware interaction.</p>
</blockquote>
<div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;">
<i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">
&#xe683;   
</i>
<span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span>
<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11953352/why-ia32-does-not-allow-memory-to-memory-mov" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Stackoverflow</a>
<span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"Why IA32 does not allow memory to memory mov?"
</span>
</div>
### 程序执行过程与跟踪

<p>程序由<code>Shell</code>(操作系统的外壳程序,用户使用Shell来操作计算机系统进行工作  (如DOS中的<code>command.com</code>就是一个Shell) 加载入内存</p>
<p> 之后Shell将设置<code>CS:IP</code>来指向程序的<code>入口点</code>, 然后暂停运行, 将程序交给CPU执行.</p>
<p>待任务执行完毕后, 控制返回到Shell , 屏幕显示由当前盘符和当前路径组成的提示符,等待用户输入.(返回到加载者)</p>
<h3 id="📌-实验三-编程-编译-连接-跟踪-分析"><a href="#📌-实验三-编程-编译-连接-跟踪-分析" class="headerlink" title="📌 实验三 - 编程|编译|连接|跟踪     - - 分析"></a>📌 实验三 - 编程|编译|连接|跟踪     - - 分析</h3><blockquote>
<p> debug 跟踪以下程序执行过程 , 记录每步执行后相关寄存器中内存和栈顶内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,2000H</span><br><span class="line">    mov ss,ax ; ss &#x3D; ax &#x3D; 2000H</span><br><span class="line">    mov sp,0</span><br><span class="line">    add sp,10 ; sp &#x3D; AH</span><br><span class="line">    ;; 注意pop执行顺序 , 首先将栈顶内容送入对应寄存器 , 再更新SP(栈指针)</span><br><span class="line">    pop ax  ; 内存追踪 ax &#x3D; 076cH , SP 新指向下个字开始处 &#x3D; SP + 2 &#x3D; C  ,   新栈顶 2000:C</span><br><span class="line">    pop bx ;  bx &#x3D; 01a4H , SP &#x3D; SP + 2 &#x3D; E 新栈顶 2000:E</span><br><span class="line">    </span><br><span class="line">    ;; 执行顺序与pop相反 , 优先处理SP , 再处理压栈操作</span><br><span class="line">    push ax ; sp &#x3D; sp - 2 &#x3D; C , 将 ax 入栈 到 2000:C(D) &#x3D;&gt; 01A4H &#x3D;&gt; 076CH(结果)</span><br><span class="line">    push bx ; sp &#x3D; sp -2 &#x3D; A , bx 入栈 至 2000:A(B) &#x3D;&gt; 01A4H &#x3D;&gt; 01A4H</span><br><span class="line">    </span><br><span class="line">    pop ax ; 出栈 , ax &#x3D; 01A4H , sp &#x3D; sp + 2 &#x3D; C </span><br><span class="line">    pop bx ; 出栈 , bx &#x3D; 076CH , sp &#x3D; E</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h ; ax &#x3D; 4c00H</span><br><span class="line">    int 21h ; p</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>✨</p>
<h3 id="Base-Register-bx-And-Loop-instruction"><a href="#Base-Register-bx-And-Loop-instruction" class="headerlink" title="Base Register[bx] And Loop instruction"></a>Base Register[bx] And Loop instruction</h3><p><code>[bx]</code>(base, 基址寄存器 , 常用于地址索引 )实际为一个偏移地址EA , 段地址SA默认存放在<code>DS</code>中</p>
<p>LOOP 指令格式 :<code> loop 标号</code> ,  通过loop指令实现循环功能 , 通过 <code>CX ( count )寄存器</code>控制循环次数 </p>
<p>执行顺序 : </p>
<ul>
<li>(CX) = (CX) -1</li>
<li>判断 若 CX &gt; 0 , 则向前转至 <code>标号</code> 处执行 , 若 CX = 0 , 则继续向下执行</li>
</ul>
<p>值得注意的是, 这里跳转到 标号 处,相当于高级语言中常见的 for \ while 等 循环中常见的 条件循环 , 汇编实现为 jle,jmp,jne等. 或许之后会详细提到</p>
<p>总体程序框架:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s: ; 标号:需要循环的程序段</span><br><span class="line">loop s ; loop label</span><br></pre></td></tr></table></figure>

<p><strong>Pseudo code</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CX &#x3D; CX - 1</span><br><span class="line">if CX &lt;&gt; 0 then</span><br><span class="line">jump to label</span><br><span class="line">else</span><br><span class="line">no jump, continue</span><br></pre></td></tr></table></figure>



<h4 id="Debug和汇编编译器MASM对指令的不同处理"><a href="#Debug和汇编编译器MASM对指令的不同处理" class="headerlink" title="Debug和汇编编译器MASM对指令的不同处理"></a>Debug和汇编编译器MASM对指令的不同处理</h4><p>若处理以<code>[]</code>包含的指令时, 型如<code>[idata]</code>,它们的处理结果如下</p>
<p>Debug 将<code>[idata]</code>视作一个内存单元, 将内部<code>idata</code>作为内存单元的偏移地址</p>
<p>编译器将<code>[idata]</code>解释作<code>idata</code></p>
<p><code>如果要让编译器将其解释为一个 内存单元, 则必须在[]前显式的给出段地址DS</code></p>
<h4 id="Concept-段前缀"><a href="#Concept-段前缀" class="headerlink" title="(Concept)段前缀"></a>(Concept)段前缀</h4><p>用于<strong>显式指明</strong>内存单元的段地址的<code>&quot;DS:&quot;,&quot;CS:&quot;,&quot;SS:&quot;,&quot;ES:&quot;</code>, 在汇编语言中被称为 <code>段前缀</code></p>
<h3 id="📌-实验四-bx-与Loop的使用-3-分析"><a href="#📌-实验四-bx-与Loop的使用-3-分析" class="headerlink" title="📌 实验四 - [bx]与Loop的使用 (3)     - - 分析"></a>📌 实验四 - [bx]与Loop的使用 (3)     - - 分析</h3><blockquote>
<p>补全程序 , 将 mov ax,4c00H 之前的指令复制到内存 0:200中</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">; quiz3</span><br><span class="line">; cx &#x3D; 001BH &#x3D; 27D NOTE</span><br><span class="line">; 23 bytes before mov ah,4cH , i.e. Hexadecimal as 17H</span><br><span class="line"></span><br><span class="line">    ; when a programm was loaded to the memory , cs:ip will initialized as the first address of the program</span><br><span class="line">    mov ax,cs    ; # 补全1</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0020H    ;  &#x3D; 0020:0 &#x3D; 00200 &#x3D; es</span><br><span class="line">    ; init target</span><br><span class="line">    mov es,ax   ; es extra segment register ( also refers to a segment in the memory which is another data segment in the memory.)</span><br><span class="line">    ; es stores the segment address of purpose</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,17H   ; 从 0 ~ cs:16H # 补全2</span><br><span class="line"></span><br><span class="line">    s:mov al,[bx]   ; ds:[bx]</span><br><span class="line">    mov es:[bx],al  ; es:[bx] &#x3D; 20:bx &#x3D; (20H*16+bx)</span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ah,4cH</span><br><span class="line">    int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">; copy the instructions before mov ax,4c00h to 0:200</span><br><span class="line">; 23 bytes , 从debug中得之第一条指令到 mov ah,4ch 之前的指令占据23bytes的空间</span><br></pre></td></tr></table></figure>

<p>通过debug获取 程序的总字节量, 计算于 mov ax,4c00H之前的字节量.( 且注意debug中以十六进制表示的数据)</p>
<p>可以发现需要获取的数据在<code>076C:0017之前</code>,也就是从偏移地址<code>0~16H</code>总共<code>23(17H)</code>个字节</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/03/17/R9hmx5IPWtUeobj.png" alt="image-20220317111236284"></p>
<!--
<span style="display: block; color: darkgray; font-size: 5px; font-style: italic; margin-top: -20px; margin-left:30%;">结果</span>
--->

<h3 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h3><p><strong>在代码段中使用数据</strong>: 可以使用<code>dw(define word)</code>定义字型数据.</p>
<p><strong>利用end</strong>的另一个作用:<code>通知编译器程序的入口点在何处</code>,可以使用<code>Start</code> 标号指明程序入口点</p>
<h4 id="🍊-程序分析-6-3"><a href="#🍊-程序分析-6-3" class="headerlink" title="🍊 程序分析 6.3"></a>🍊 程序分析 6.3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ; 8 words &#x3D; 16bytes</span><br><span class="line">    ; 预期的内存空间 cs:0 ~ cs:F</span><br><span class="line">    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ; 16 words &#x3D; 32bytes</span><br><span class="line">    </span><br><span class="line">　　 ; 共 48 bytes ( 即 0~47 共 2F个数据 , 初始为空栈 , SS:SP应指向其后面一个数据 即 2F+1 &#x3D; 30H) </span><br><span class="line">; REFER : When the stack is empty ,SP Point to the address of the next memory unit at the bottom of the stack , namely SP &#x3D; At the bottom of the stack +1.</span><br><span class="line"></span><br><span class="line"> start:mov ax,cs</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,30h   </span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"> s:push cs:[bx]    ; 数据入栈 sp -&#x3D; 2</span><br><span class="line">    add bx,2   </span><br><span class="line">    loop s    </span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line"> s0:pop cs:[bx]   </span><br><span class="line">    add bx,2</span><br><span class="line">    loop s0   </span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">    </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="编写多段程序"><a href="#编写多段程序" class="headerlink" title="编写多段程序"></a>编写多段程序</h4><p>利用<code>assume</code>伪指令将定义的段和相关的寄存器联系起来 , 对于不同的段, 要有不同的<code>段名</code></p>
<p>段名就相当于一个标号,它代表了一个段的<code>段地址</code> , 编译器会把它处理为一个表示段地址的数值</p>
<p>注意在8086CPU<code>不允许直接将数值传入段寄存器中</code>, 所以要将定义的段程序赋给特定的寄存器时需要一个寄存器作中转.</p>
<p>CPU如何处理所定义的段的内容, 当作指令执行或是数据访问, 亦或是栈空间… 完全取决于程序中具体的汇编指令 , 及汇编指令中对<code>CS:IP</code> <code>SS:SP</code> <code>DS </code>等寄存器的设置决定</p>
<h3 id="📌-实验五-编写与调试多段程序-分析"><a href="#📌-实验五-编写与调试多段程序-分析" class="headerlink" title="📌 实验五 - 编写与调试多段程序     - - 分析"></a>📌 实验五 - 编写与调试多段程序     - - 分析</h3><p>编译链接并跟踪调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">; Experiment 5</span><br><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">; 数据段定义</span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h ; ,0789h,0abch,0defh,0fedh,0cbah,0987h ; 16bytes</span><br><span class="line">data ends</span><br><span class="line">; 栈段定义</span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0 ; ,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: </span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16   ; 指向第四个字型数据</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    push ds:[0]</span><br><span class="line">    push ds:[2]</span><br><span class="line">    pop ds:[2]</span><br><span class="line">    pop ds:[0]</span><br><span class="line">    </span><br><span class="line">    mov ah,4cH</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">;---------------</span><br><span class="line"></span><br><span class="line">; Experiment 5 quiz 4</span><br><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">; 数据段定义</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: </span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16   ; 指向第四个字型数据</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    push ds:[0]</span><br><span class="line">    push ds:[2]</span><br><span class="line">    pop ds:[2]</span><br><span class="line">    pop ds:[0]</span><br><span class="line">    </span><br><span class="line">    mov ah,4cH</span><br><span class="line">    int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0123h,0456h ; ,0789h,0abch,0defh,0fedh,0cbah,0987h ; 16bytes</span><br><span class="line">data ends</span><br><span class="line">; 栈段定义</span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0 ; ,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<!-- 实验五 -->

<h4 id="Experiment-5-Quiz-1"><a href="#Experiment-5-Quiz-1" class="headerlink" title="Experiment 5 Quiz 1"></a><strong>Experiment 5 Quiz 1</strong></h4><ul>
<li><p>程序返回前, data段中数据为 23 01 56 04… 共16个字节 , <strong>剩下部分用00补全</strong></p>
</li>
<li><p>程序返回前, <strong>CS = 076E    SS = 076D    DS = 076C</strong></p>
</li>
<li><p>程序加载后, 设Code段的段地址为X , 则data 段的段地址为 <code>X-2</code> , stack段的段地址为 <code>X-1</code></p>
</li>
<li><p>对于如下定义的段:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name segment</span><br><span class="line">...</span><br><span class="line">name ends</span><br></pre></td></tr></table></figure>

<p>如果段中的数据占N个字节,则程序加载后 , 该段实际占有的空间为 (N / 16 + 1 )<strong>N小于16,则向下取整</strong> * 16 个字节 , <strong>若N大于16 , 则向上取整</strong> … </p>
<div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;">
<i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">
&#xe683;   
</i>
<span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span>
<a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/390585699" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">CSDN</a>
<span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"关于 (N / 16 + 10) * 16"
</span>
</div>

<ul>
<li>若将伪指令 <strong>end start</strong> 改为 <strong>end</strong> (不指明程序的入口点) . 程序均可正常执行 , 只是不再从指定的入口点开始执行,而是从程序开始的程序段处开始执行, 若此程序段为数据段或栈段, 编译器会将其处理为汇编指令并执行.</li>
</ul>
<!-- 实验五 第五题 -->

<h4 id="Experiment-5-Quiz-5"><a href="#Experiment-5-Quiz-5" class="headerlink" title="Experiment 5 Quiz 5"></a><strong>Experiment 5 Quiz 5</strong></h4><blockquote>
<p>将a段和b段数据依次相加 , 结果存在cg段</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">; define byte</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">; a segment occpied 8 bytes in memory</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">cg segment</span><br><span class="line">    db 0,0,0,0,0,0,0,0</span><br><span class="line">cg ends</span><br><span class="line"></span><br><span class="line">; 实现: 两次循环 分别用寄存器指向 a,c 及 b,c即可</span><br><span class="line">code segment</span><br><span class="line">; main</span><br><span class="line">start:</span><br><span class="line">    ; change ES point target</span><br><span class="line">    ; DS point to C</span><br><span class="line">    mov ax,cg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ; ES point to A</span><br><span class="line">    mov ax,a</span><br><span class="line">    mov es,ax</span><br><span class="line">    ; bx - excursion address</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line">    s1:</span><br><span class="line">    mov al,es:[bx]</span><br><span class="line">    add [bx],al</span><br><span class="line">    inc bx</span><br><span class="line">    loop s1</span><br><span class="line">    </span><br><span class="line">    ; ES point to B</span><br><span class="line">    mov ax,b</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,8</span><br><span class="line">    s2:</span><br><span class="line">    mov al,es:[bx]</span><br><span class="line">    add [bx],al</span><br><span class="line">    inc bx</span><br><span class="line">    loop s2</span><br><span class="line"></span><br><span class="line">    mov ah,4c</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">; outcome : 02 04 06 08 0A 0C 0E 10</span><br></pre></td></tr></table></figure>

<!-- 实验五 第六题 -->

<h4 id="Experiment-5-Quiz-6"><a href="#Experiment-5-Quiz-6" class="headerlink" title="Experiment 5 Quiz 6"></a><strong>Experiment 5 Quiz 6</strong></h4><blockquote>
<p>用push指令将 A 段中的前8个字型数据逆向存储到B段中</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">; E5q6</span><br><span class="line">assume cs:code</span><br><span class="line">a segment</span><br><span class="line">    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    ; main</span><br><span class="line">    start:</span><br><span class="line">    mov ax,a</span><br><span class="line">    mov es,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,b</span><br><span class="line">    mov ss,ax   ; b段 段地址 赋值给栈段 作栈空间</span><br><span class="line">    mov sp,10H</span><br><span class="line"></span><br><span class="line">    mov cx,8</span><br><span class="line">    mov bx,0</span><br><span class="line">    s:</span><br><span class="line">    push es:[bx]</span><br><span class="line">    add bx,2 ; what stored is a word</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ah,4cH</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/03/29/gw7UOLXoJSEbRQr.png" alt="运行结果"></p>
<!-- Chapter 7 -->

<h3 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h3><blockquote>
<p>如果一个问题的解决方案，使我们陷入一种矛盾之中。那么，很可能是我们考虑问题的出发点有了问题，或是说，我们起初运用的规律并不合适。</p>
</blockquote>
<h4 id="AND-与-OR-指令"><a href="#AND-与-OR-指令" class="headerlink" title="AND 与 OR 指令"></a>AND 与 OR 指令</h4><p>与基本逻辑<code>与 &amp;</code> <code>或 |</code> 相同 , 只是汇编中皆按位进行运算</p>
<p><code>AND</code>: 逻辑与指令, 按位进行与运算 , 通过该指令将操作对象相应位设为 0 ,其他位不变</p>
<p><code>OR</code>: 逻辑或指令, 按位进行或运算 , 通过该指令将操作对象相应位设为 1 ,其他位不变</p>
<h4 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h4><p>在汇编程序中 , 可以使用形如 <code>&#39;....&#39;</code>的方式指明数据是以字符的形式给出的 , 编译器会将其转换为相应的 ASCII 码</p>
<p>E.G.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#39;unIX&#39; ; 相当于 db 75H,6EH,49H,58H 与字符的 ascii码相对应</span><br></pre></td></tr></table></figure>

<h4 id="BX-IDATA"><a href="#BX-IDATA" class="headerlink" title="[ BX + IDATA ]"></a>[ BX + IDATA ]</h4><p>可以以此标题方式来灵活的表明一个内存单元 ， <code>[bx + idata]</code>表示一个内存单元，偏移地址为 <code>(bx) + idata</code></p>
<p>E.G.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200] ; 将一个内存单元存入AX , 这个内存单元占2个字节， 存放一个字，偏移地址为 bx的值 + 200 , 段地址在ds中</span><br><span class="line">; 即 [(ds)*16 + (bx) + 200]</span><br><span class="line"></span><br><span class="line">; 也可写作：</span><br><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,[bx].200</span><br><span class="line">mov ax,200[bx]</span><br></pre></td></tr></table></figure>

<h4 id="SI-Source-Index-Register-amp-DI-Destination-Index-Register"><a href="#SI-Source-Index-Register-amp-DI-Destination-Index-Register" class="headerlink" title="SI (Source Index Register) &amp; DI (Destination Index Register)"></a>SI (Source Index Register) &amp; DI (Destination Index Register)</h4><p><code>SI</code>和<code>DI</code>都是<code>变址寄存器(Index Register)</code></p>
<blockquote>
<p>它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p>
</blockquote>
<div style="border: olivedrab solid 1px; border-radius:2px;  height: 34px; width: 100%; display: inline-block; margin-bottom:25px;">
<i class="iconfont" style="font-size:18px;font-weight:700;color: olivedrab;  padding-left: 5px; vertical-align: middle; padding-bottom:-2px; position:relative; bottom:2px;">
&#xe683;   
</i>
<span style="color: olivedrab; font-size: 15px; font-family: sans-serif; margin-right: 4px; ">Refer</span>
<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8/7680616" style="background-color: #8BBA2E; color: #EDEDED; padding: 5px 10px; font-size: 13px; ">Baike.Baidu</a>
<span style="text-align: center; color: #5D654E; border-left: olivedrab 1px solid; padding-left: 10px; margin-left:10px; font-family: Georgia, serif;">"变址寄存器"
</span>
</div>

<h4 id="不同寻址方式的灵活应用"><a href="#不同寻址方式的灵活应用" class="headerlink" title="不同寻址方式的灵活应用"></a>不同寻址方式的灵活应用</h4><p>不同的寻址方式:</p>
<p><code>[idata]</code> 用一个常量来表示地址, 可用于直接定位一个内存单元.<code>直接寻址</code></p>
<p><code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元. <code>寄存器间接寻址</code></p>
<p><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元.<code>寄存器相对寻址</code></p>
<p><code>[bx+si]</code>用两个变量表示地址. <code>基址变址寻址</code></p>
<p><code>[bx+si+idata]</code>用两个变量和一个常量表示地址。<code>相对基址变址寻址</code></p>
<p>自顶向下逐渐可以用更灵活的寻址方式来定位一个内存单元的地址 。这使得数据在使用者的角度可以以<code>结构化</code>的角度看待。</p>
<h4 id="关于数据的暂存"><a href="#关于数据的暂存" class="headerlink" title="关于数据的暂存"></a>关于数据的暂存</h4><p>有时会遇到需要数据暂存的情况 , 如嵌套循环的CX , 作为计数器使用 . 由于寄存器的数量有限, 且每个程序使用的寄存器不一样 , 遂需要更为通用的方案</p>
<p>在不考虑使用寄存器的情况下</p>
<ul>
<li>可以将要暂存的数据存放到内存空间中,需要的时候再从内存单元中恢复. 但是当数据量多的时候，这样的存储方式需要记住哪个数据放到 了哪个单元。容易引起程序混乱。</li>
<li>将需要暂存的数据存入栈中 ， 利用压栈出栈与 栈顶指向 控制栈空间的数据</li>
</ul>
<h3 id="📌-实验六-灵活定位内存地址并修改值-分析调试"><a href="#📌-实验六-灵活定位内存地址并修改值-分析调试" class="headerlink" title="📌 实验六 - 灵活定位内存地址并修改值     - - 分析调试"></a>📌 实验六 - 灵活定位内存地址并修改值     - - 分析调试</h3><blockquote>
<p>将datasg段中的每个单词的前四个字母改为大写字母</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">; Experiment 6</span><br><span class="line">; initialize regiter&#39;s point address</span><br><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0 ; 16 bytes</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db &#39;1. display      &#39;</span><br><span class="line">    db &#39;2. brows        &#39;</span><br><span class="line">    db &#39;3. replace      &#39;</span><br><span class="line">    db &#39;4. modify       &#39;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    ; main</span><br><span class="line">    start:</span><br><span class="line">    ; associate register with segment name</span><br><span class="line">    mov ax,stacksg</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov bx,3    ; start point of string</span><br><span class="line">    mov sp,10H</span><br><span class="line"></span><br><span class="line">    mov cx,4</span><br><span class="line">    ; external loop statement</span><br><span class="line">    s0:</span><br><span class="line">    mov si,0</span><br><span class="line">    push cx ; store cx(external) to stack temporary</span><br><span class="line"></span><br><span class="line">    ; internal  loop statement , refresh cx when external loop each time</span><br><span class="line">    mov cx,4</span><br><span class="line">    s1:</span><br><span class="line">    mov al,[bx+si]</span><br><span class="line">    and al,11011111B ; 5th number of Binary set to ZERO &#x3D;&gt; capital letter</span><br><span class="line">    mov [bx+si],al</span><br><span class="line">    inc si</span><br><span class="line">    loop s1</span><br><span class="line"></span><br><span class="line">    ; restore CX value</span><br><span class="line">    pop cx</span><br><span class="line">    add bx,10H ; point to next string </span><br><span class="line"></span><br><span class="line">    loop s0</span><br><span class="line"></span><br><span class="line">    mov ah,4CH</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h3><ul>
<li>要处理的数据在何处</li>
<li>要处理的的数据有多长</li>
</ul>
<h4 id="于汇编中数据位置的表达"><a href="#于汇编中数据位置的表达" class="headerlink" title="于汇编中数据位置的表达"></a>于汇编中数据位置的表达</h4><ul>
<li>立即数<code>idata</code>,在汇编中直接给出的数据</li>
<li>寄存器 , 汇编指令中需给出相应的寄存器名</li>
<li>段地址(SA) 和 偏移地址(EA) , 汇编中可用<code>[x]</code>形式给出EA , SA存在于某个段寄存器中</li>
</ul>
<h4 id="指明要处理的数据长度-x-ptr"><a href="#指明要处理的数据长度-x-ptr" class="headerlink" title="指明要处理的数据长度 - x ptr"></a>指明要处理的数据长度 - x ptr</h4><p>8086CPU可处理两种长度的数据 Byte 和 Word ,在指令中需要指明需要处理的数据的尺寸.</p>
<ul>
<li>可以通过寄存器名来指明数据的尺寸.</li>
<li>在没有寄存器名的情况下,可以使用形如<code>X ptr</code> 来指明内存单元的长度 , <code>X</code> 在汇编中可以为<code>word</code>或是<code>byte</code> .<br>如 <code>mov word ptr ds:[0],1</code>  <code>inc word ptr [bx]</code> 这俩指令使用 <code>word ptr</code> 指明了指令访问的内存单元是一个<code>字单元</code> .</li>
</ul>
<p>注意有的指令就不要指明内存单元的长度了 , 像是<code>push \ pop</code>,其只能进行字操作.</p>
<h4 id="div-Instruction"><a href="#div-Instruction" class="headerlink" title="div Instruction"></a>div Instruction</h4><p>即除法指令 , 需要注意几个问题</p>
<ul>
<li><p>除数 的两种情况 : <code>8bit</code> &amp; <code>16bit</code> , 在一个寄存器或是内存单元中</p>
</li>
<li><p>被除数 默认放在<code>AX</code>中 或是 <code>DX 和 AX</code>中 , 情况如下</p>
<ul>
<li>若除数为 8位 , 被除数则为 <code>16位 </code>, 此时被除数默认存放在 <code>AX</code>中</li>
<li>若除数为16位 , 被除数则为 <code>32位 </code>, 此时被除数被存放在 <code>DX和AX</code>中 ,<strong>DX中存放高16位 , AX中存放低16位</strong></li>
</ul>
</li>
<li><p>对于计算结果的存储</p>
<ul>
<li>若除数为 8位 , 则 <code>AL</code> 将存储 除法操作的 <code>商</code> , <code>AH</code>中存储的则是<code>余数</code></li>
<li>若除数为 16位 , 则 <code>AX</code> 中将存储 除法操作的 <code>商</code> , <code>DX</code> 中存储的是<code>余数</code></li>
</ul>
</li>
</ul>
<p>一般寄存器的存储主要是关于被除数 和 结果.</p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; 1001 &#x2F; 100 div calculation</span><br><span class="line">; quizzes about div instruction</span><br><span class="line"></span><br><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">    ; cuz the dividend&#39;s HEX &#x3D; 3E9H , a 16bits register is suitable,it stored into AX register. And the divisor needs a 8bits register to store.</span><br><span class="line">    </span><br><span class="line">    mov ax,3E9H</span><br><span class="line">    mov bl,64H</span><br><span class="line">    div bl ; al &#x3D; qutient , ah &#x3D; remainder</span><br><span class="line"></span><br><span class="line">    ; result: AX &#x3D; 010AH</span><br><span class="line"></span><br><span class="line">    mov ah,4CH</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>####　伪指令 - dd (define dword)</p>
<p> <code>dd</code>用来定义<code>双字</code> 型数据 , 占用<code>32</code>位 , 需要<code>2个16位寄存器</code>来分别存储其高低16为位</p>
<h4 id="dup-Operator"><a href="#dup-Operator" class="headerlink" title="dup Operator"></a>dup Operator</h4><p>dup是一个操作符 , 和 <code>db \ dw \ dd</code> 一样, 其也是由编译器识别处理的符号 , 与他们(数据定义指令)配合使用 , 用以进行<code>数据的重复</code>.</p>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0) ; 定义了3个字节 , 他们的值都是 0  , 相当于db 0,0,0</span><br><span class="line">; 或者这样解释 : 定义了字节&quot;0&quot;,重复了3次, 相当于 db 0,0,0</span><br><span class="line"></span><br><span class="line">db 3 dup (0,2,3) ; 定义了9个字节 , 他们的值都是 0,2,3 , 相当于 db 0,2,3,0,2,3,0,2,3</span><br><span class="line">db 3 dup (&#39;abc&#39;,&#39;ABC&#39;)</span><br><span class="line">;定义了I8个字节，它们是abcABCabcABCabcABC,相当于db&#39;abcABCabcABCabcABC。</span><br></pre></td></tr></table></figure>

<p>可见，dup的使用格式如下:</p>
<ul>
<li><code>db 重复的次数 dup（重复的字节型数据）</code></li>
<li><code>dw 重复的次数 dup（重复的字型数据）</code></li>
<li><code>dd 重复的次数 dup（重复的双字型数据）</code></li>
</ul>
<h3 id="📌-实验七-寻址方式在结构化数据访问中的应用-分析调试"><a href="#📌-实验七-寻址方式在结构化数据访问中的应用-分析调试" class="headerlink" title="📌 实验七 - 寻址方式在结构化数据访问中的应用     - - 分析调试"></a>📌 实验七 - 寻址方式在结构化数据访问中的应用     - - 分析调试</h3><p>; 比较综合的一个实验, 融合之前的知识 </p>
<blockquote>
<p> 将 data 段中的数据按照以下指定格式写入 table段</p>
</blockquote>
<p>写到发狂.jpg</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/04/12/dNZf4MG1zna7lws.png" alt="存储格式"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;</span><br><span class="line">    db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;</span><br><span class="line">    db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;</span><br><span class="line">    ;以上是表示21年的21个字符串，每个占4字节</span><br><span class="line">    dd 16,22,382,1356,2390,8000,16000,244486,50065,97479,140417,197514</span><br><span class="line">    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line">    ;以上是表示21年公司总收入的21个双字型数据，每个占四字节</span><br><span class="line">    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">    dw 11542,14430,15257,17800</span><br><span class="line">    ;以上是表示21年公司雇员人数的21个字型数据</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    db 21 dup (&#39;year sume ne ?? &#39;)  ; 正好十六字节</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">    db 10H dup (0)</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">; write a year&#39;s all data in every loop</span><br><span class="line">codesg segment</span><br><span class="line">    start:</span><br><span class="line">    ; Initilize all data register</span><br><span class="line">    ; es 指向 data , ds 指向 table</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,table</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov ax,stacksg</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10H</span><br><span class="line"></span><br><span class="line">    mov bx,0   ; 索引table中的列(字节单位)</span><br><span class="line">    mov di,0   ; year 字节型 一个字符串4个字节</span><br><span class="line">    mov si,54H ; point to income in DATA SEGMENT 双字型</span><br><span class="line">    mov bp,168 ; point to staff in DATA SEGMENT 字型</span><br><span class="line">    </span><br><span class="line">    mov cx,21</span><br><span class="line">    s:</span><br><span class="line">    ; 同样也是一次处理一行的数据 , ax作中转寄存器</span><br><span class="line">    ; bx 将每行看作一个结构型数据 , 用.idata 定位每个数据项(年份 \ 收入 \ 员工 等.. )</span><br><span class="line">    ; NOTE  copy year</span><br><span class="line">    mov ax,es:[di]</span><br><span class="line">    mov [bx].0,ax</span><br><span class="line">    add di,2 ; 注意x86架构采用的是小端存储模式(高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中) , 所以此指令执行将指向高位字节(高16位)</span><br><span class="line"></span><br><span class="line">    mov ax,es:[di]</span><br><span class="line">    mov [bx].2,ax ; idata更新 , 在内存中存储 高十六位</span><br><span class="line">    add di,2 ; 指向下一年</span><br><span class="line">    ; 至此年份处理完毕</span><br><span class="line"></span><br><span class="line">    ; 处理收入</span><br><span class="line">    mov ax,es:[si] ; si所指向的结构型数据 &#x3D;&gt; 收入 , 此处同样以字的方式进行数据处理</span><br><span class="line">    push ax ; 将 ax 存入栈中, 以便后续进行人均收入的计算 , 低16位</span><br><span class="line">    mov [bx].5,ax</span><br><span class="line">    add si,2</span><br><span class="line">    ; NOTE 处理高16位</span><br><span class="line">    mov ax,es:[si]</span><br><span class="line">    push ax ; 将其高16位入栈</span><br><span class="line">    mov [bx].7,ax</span><br><span class="line">    add si,2 ; 指向下一个收入数据</span><br><span class="line">    ; 至此 收入部分处理结束</span><br><span class="line"></span><br><span class="line">    ; NOTE 开始处理雇员结构数据 字型数据处理</span><br><span class="line">    mov ax,es:[bp]</span><br><span class="line">    mov [bx].0AH,ax</span><br><span class="line">    ; 至此雇员结构数据处理完毕</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    div word ptr [bx].0AH</span><br><span class="line">    mov [bx].0dH,ax</span><br><span class="line">    add bp,2 ; 指向下一个雇员数据</span><br><span class="line"></span><br><span class="line">    add bx,10H    ; 指向下一行</span><br><span class="line"></span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ah,4CH</span><br><span class="line">    int 21h    </span><br><span class="line"></span><br><span class="line">    ; average of income</span><br><span class="line">    ; divisor(staff) is a Word(16bits) , therefore the dividend(total income) should be a dword(32bits)</span><br><span class="line">    ; staff is divisor while total income is dividend </span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="转移指令及其原理"><a href="#转移指令及其原理" class="headerlink" title="转移指令及其原理"></a>转移指令及其原理</h3><blockquote>
<p>可以修改IP , 或同时修改 CS和IP的指令统称为 <strong>转移指令</strong></p>
</blockquote>
<p>针对8086CPU来说, 其<code>转移行为</code>有以下几类:</p>
<ul>
<li>只修改IP时 , 为段内转移</li>
<li>同时修改CS和 IP 时 , 为段间转移</li>
</ul>
<p>针对转移指令对IP修改范围的不同, 段内转移还分为: <code>短转移  (IP修改范围: -128 ~ 127)</code>和 <code>近转移 (IP修改范围: -32768 ~ 32767)</code>   (前后八位的区别吗)</p>
<h4 id="操作符-Offset"><a href="#操作符-Offset" class="headerlink" title="操作符 Offset"></a>操作符 Offset</h4><p>操作符<code>offset</code>在汇编语言中是由编译器处理的符号 , 它的功能是<code>取得标号的偏移地址</code></p>
<h4 id="Jmp-指令"><a href="#Jmp-指令" class="headerlink" title="Jmp 指令"></a>Jmp 指令</h4><p><code>Jmp</code>指令为无条件转移指令 , <code>可以只修改IP , 或同时修改 CS和IP</code></p>
<p>此指令需要给出两种信息:</p>
<ul>
<li>转移的距离 ( <code>段间</code>转移 \ <code>段内 短</code>转移 \ <code>段内 近</code>转移 )</li>
<li>转移的目的地址</li>
</ul>
<h5 id="依据位移进行转移的-JMP-指令-补码"><a href="#依据位移进行转移的-JMP-指令-补码" class="headerlink" title="依据位移进行转移的 JMP 指令 +. 补码"></a>依据位移进行转移的 JMP 指令 +. 补码</h5><p><code>Jmp short 标号 ( 转到标号处执行指令 )</code></p>
<blockquote>
<p> 此格式的 JMP指令 实现的是段内短转移 , 对<code>IP</code>的修改范围为 -128 ~ 127 , 即向前转移最多越过 128个字节 , 向后转移最多越过 127个字节 , “Short” 说明了其进行得是短转移 ,间接说明Short类型为8位 ,  “标号”存在于代码段中 , 是指令转移的目的地</p>
</blockquote>
<p>注意 在<code>jmp short 标号</code>指令所对应的机器码中,并不包含转移的 <code>目的地址</code>,而包含的是<code>转移的位移</code>, 此位移是编译器根据汇编指令中的’标号’计算出来的。(实际也就是目标地址起始偏移地址 - 当前指令起始偏移地址)</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://s2.loli.net/2022/05/19/cKqeIENwYpX75Qu.png" alt="位移计算方法,请忽略图上标注"></p>
<p><code>jmp short 标号</code>的功能实际为 : <code>(IP) =  (IP) + 8位位移</code></p>
<p>位移本质上是一个偏移量 , 由 jmp 指令<code>后一条指令的第一个字节地址</code>(IP) [实际就是后一条指令的开始字节值] + 位移 = 目标地址偏移</p>
<ul>
<li>8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</li>
<li><code>short</code>指明此处的位移为8位位移</li>
<li>8位位移的范围为-128~127，用<code>补码</code>表示 , 8位的最大最小值</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
<p>可得在 <code>jmp short</code>指令的机器指令中 , 包含的是跳转到目标指令的相对位置 偏移量 , 而不是转移的目标地址</p>
<blockquote>
<p>补码 Review:</p>
<p>以8位数据表示 有符号数  , 其最高位表符号 , 1 为负 , 0 为正 . 用其他位表示数值</p>
<p>补码的基本思想:先确定用 0000 0000b<del>0111 1111b表示0</del>127，然后再用它们按位取反加1后的数据表示负数。</p>
<p>补码方案特性:</p>
<ul>
<li><p>最高位为1表示负数</p>
</li>
<li><p>正数的补码取反加1后，为其对应的负数的补码：负数的补码取反加1后，为其绝对值。</p>
</li>
</ul>
<p>由于一个负数的补码不太容易看出它所表示的数据 , 但是利用补码的特性将其 按位取反再加1 后可得知其 绝对值 , 则负数的值取相反数即可.</p>
<p>顺便一提 , <code>计算机都是以补码的形式存储数据的</code></p>
</blockquote>
<p><code>段内近转移: short near ptr 标号</code></p>
<p>与短转移相似</p>
<ul>
<li>16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</li>
<li><code>near</code>指明此处的位移为16位位移</li>
<li>16位位移的范围为-32768~32767，用<code>补码</code>表示 , 8位的最大最小值</li>
<li>16位位移由编译程序在编译时算出。</li>
</ul>
<p><code>jmp far ptr 标号</code> 实现的是<code>段间</code>转移  , 又称为<code>远</code>转移</p>
<p><code>far ptr</code> 指明了指令用标号的段地址和偏移地址修改<code>CS和IP</code> , 在机器码中 , <code>高地址部分存放段地址  , 低地址存放偏移地址</code> , 顺序遵循小端存储模式</p>
<blockquote>
<p>Recommend to refer : 汇编编译器(MASM.exe) 对 jmp 指令的相关处理</p>
</blockquote>
<h5 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a><strong>转移地址在寄存器中的jmp指令</strong></h5><p>格式 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 16bit reg    ; 格式</span><br><span class="line">(ip) &#x3D; (16bit reg)    ; 功能</span><br></pre></td></tr></table></figure>



<h5 id="🛠️转移地址在内存中的jmp指令"><a href="#🛠️转移地址在内存中的jmp指令" class="headerlink" title="🛠️转移地址在内存中的jmp指令"></a>🛠️转移地址在内存中的jmp指令</h5><p>两种格式 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">jmp word ptr 内存单元地址 (段内转移)</span><br><span class="line">; 从内存单元地址开始处存放着一个字 , 这个字的数据就是转移的 目的偏移地址(IP)</span><br><span class="line"></span><br><span class="line">;    e.g. </span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]    ; 注意以字类数据长度 进行传输</span><br><span class="line">; 执行后 (IP) &#x3D; 0123H</span><br><span class="line"></span><br><span class="line">jmp dword ptr 内存单元地址 (段间转移)</span><br><span class="line">; 从内存开始处存放2个字 , 高地址处的字是转移目的地的 段地址 ,  低地址的是 偏移地址</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="jcxz指令-Jump-if-CX-equals-Zero"><a href="#jcxz指令-Jump-if-CX-equals-Zero" class="headerlink" title="jcxz指令 (Jump if CX equals Zero)"></a>jcxz指令 (Jump if CX equals Zero)</h5><p>所有的<code>有条件跳转指令</code>都属于[短转移](#依据位移进行转移的 JMP 指令 +. 补码)(段内短转移),其在机器码中包含的是转移的<code>位移</code>,而非目的地址</p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jcxz flag    </span><br><span class="line">; 如果 (cx) &#x3D;&#x3D; 0 , 则跳转到标号处 , 否则(cx!&#x3D;0)继续向下执行</span><br><span class="line">; flag &#x3D; 标号</span><br><span class="line"></span><br><span class="line">(类C描述)相当于:</span><br><span class="line">if ((cx)&#x3D;&#x3D;0) jmp short 标号;</span><br></pre></td></tr></table></figure>



<h4 id="loop-指令"><a href="#loop-指令" class="headerlink" title="loop 指令"></a>loop 指令</h4></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ha1Cy0nMeowo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fxlabtinystar.cn/2021/09/17/AssemblyLearning/">http://fxlabtinystar.cn/2021/09/17/AssemblyLearning/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fxlabtinystar.cn" target="_blank">星 愿 🍃</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/09/17/CfiyHp6RdIWcTJa.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="😊 感谢支持"/></a><div class="post-qr-code-desc">😊 感谢支持</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/24/%E4%B8%80%E4%BA%9B%E8%AF%9D/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/freexmelody/cdn@master/imgGo/defaultCover2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Blog搭建问题与一些话...</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/19/MultiUBoot/"><img class="next-cover" data-lazy-src="https://i.loli.net/2021/05/26/6WZeraY8fySUNlF.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多引导系统启动盘制作</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/04/01/asmTricks/" title="以汇编揭秘编程语言的本质"><img class="relatedPosts_cover" data-lazy-src="https://s2.loli.net/2022/04/01/M6I8s9Fm43yuDav.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="relatedPosts_title">以汇编揭秘编程语言的本质</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2021/09/17/CfiyHp6RdIWcTJa.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Ha1Cy0nMeowo</div><div class="footer_custom_text">🍃 欢迎访问我的 <a href="https://fxlabtinystar.cn/">小屋</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '08CAGmWy9ofppqHz8pSaM4YD-gzGzoHsz',
      appKey: '1uV1s1EeGdm9nm7aoO7OdXQX',
      placeholder: '🍉 感觉这儿怎么样？留下你的建议叭~ \n🍒 昵称中填入QQ号会自动补全邮箱，评论头像将使用QQ头像喔！\n🤗 如果我长时间没有回答你的问题···也可以以其他方式联系我!QQ:3047124773',
      avatar: 'mp',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      master: '72a82a32bf757698635632c3cac626d9'.split(','),
      friends: '5c060ea055b5a63bab29e4987b5cd9d6,fccbdb3020abb062f027cb71162eba44,53d2758757c4b819ec93f8496dfb79b8,37df5b3e239be42a512010afe92f1bce,b2c56180d8f9222d11c43a8bd0bf81d8,4f15919e9a5ff8cd2a1c192b399fc6f2,4ad72b19b44525a50996b08ba8589700,779f1d9058c800016f6231513b3e3274,afea7f7a78694abdb4c1e82dc924a984,9d268dcc28176d85452bb51a02a5918e'.split(','),
      tagMeta: '小屋の主,友人,客官'.split(',')
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script data-pjax src="/live2d/live2d/js/index.js"></script><script src="/JsFile/FxStyle.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><link rel="stylesheet" href="/css/bottomFish.css"><script src="/JsFile/FxStyle.js"></script><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script>((window.gitter = {}).chat = {}).options = {
  disableDefaultChat: true,
};
document.addEventListener('gitter-sidecar-ready', (e) => {
  const GitterChat = e.detail.Chat
  let chat

  function initGitter () {
    chat = new GitterChat({
      room: 'MyFirstCommunity/RoomforMyBlog',
      activationElement: '#chat_btn'
    });
  }

  initGitter()

  if (false) {
    document.addEventListener('pjax:complete', () => {
      chat.destroy()
      initGitter()
    })
  }

})</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 小屋重新整理了喔！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍭开启新视野🍬</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 小屋重新整理了喔！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍭开启新视野🍬',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#49b1f5' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script></div></body></html>